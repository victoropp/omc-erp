# Comprehensive CD Pipeline for OMC ERP System
name: CD Pipeline

on:
  push:
    branches: [main]
    tags: ['v*.*.*']
  workflow_run:
    workflows: ["CI Pipeline"]
    types: [completed]
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
      services:
        description: 'Services to deploy (comma-separated, or "all")'
        required: true
        default: 'all'
      force_deploy:
        description: 'Force deployment even if tests fail'
        required: false
        type: boolean
        default: false

env:
  REGISTRY: ghcr.io
  IMAGE_NAME_PREFIX: omc-erp
  KUBECTL_VERSION: '1.28.0'
  HELM_VERSION: '3.13.0'

jobs:
  # ==============================================
  # PRE-DEPLOYMENT VALIDATION
  # ==============================================
  pre-deployment:
    name: Pre-deployment Validation
    runs-on: ubuntu-latest
    timeout-minutes: 10
    if: github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' || startsWith(github.ref, 'refs/tags/')
    
    outputs:
      environment: ${{ steps.determine-env.outputs.environment }}
      services: ${{ steps.determine-services.outputs.services }}
      version: ${{ steps.version.outputs.version }}
      should_deploy: ${{ steps.validation.outputs.should_deploy }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Determine deployment environment
      id: determine-env
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
        elif [[ "${{ github.ref }}" == refs/tags/* ]]; then
          echo "environment=production" >> $GITHUB_OUTPUT
        else
          echo "environment=staging" >> $GITHUB_OUTPUT
        fi
        
    - name: Determine services to deploy
      id: determine-services
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          echo "services=${{ github.event.inputs.services }}" >> $GITHUB_OUTPUT
        else
          echo "services=all" >> $GITHUB_OUTPUT
        fi
        
    - name: Generate version
      id: version
      run: |
        if [[ "${{ github.ref }}" == refs/tags/* ]]; then
          VERSION=${GITHUB_REF#refs/tags/}
        else
          VERSION="$(date +'%Y%m%d')-${GITHUB_SHA::7}"
        fi
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "Generated version: $VERSION"
        
    - name: Validate deployment conditions
      id: validation
      run: |
        SHOULD_DEPLOY="true"
        
        # Check if CI passed (unless force deploy)
        if [ "${{ github.event.workflow_run.conclusion }}" = "failure" ] && [ "${{ github.event.inputs.force_deploy }}" != "true" ]; then
          echo "CI pipeline failed and force_deploy is not enabled"
          SHOULD_DEPLOY="false"
        fi
        
        # Check if it's production deployment from non-main branch
        if [ "${{ steps.determine-env.outputs.environment }}" = "production" ] && [ "${{ github.ref }}" != "refs/heads/main" ] && [[ "${{ github.ref }}" != refs/tags/* ]]; then
          echo "Production deployment only allowed from main branch or tags"
          SHOULD_DEPLOY="false"
        fi
        
        echo "should_deploy=$SHOULD_DEPLOY" >> $GITHUB_OUTPUT
        
    - name: Deployment summary
      run: |
        echo "## Deployment Configuration" >> $GITHUB_STEP_SUMMARY
        echo "- **Environment**: ${{ steps.determine-env.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Version**: ${{ steps.version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Services**: ${{ steps.determine-services.outputs.services }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Should Deploy**: ${{ steps.validation.outputs.should_deploy }}" >> $GITHUB_STEP_SUMMARY

  # ==============================================
  # BUILD AND PUSH DOCKER IMAGES
  # ==============================================
  build-and-push:
    name: Build and Push Images
    runs-on: ubuntu-latest
    timeout-minutes: 45
    needs: pre-deployment
    if: needs.pre-deployment.outputs.should_deploy == 'true'
    
    permissions:
      contents: read
      packages: write
      
    strategy:
      matrix:
        service:
          - api-gateway
          - auth-service
          - transaction-service
          - station-service
          - pricing-service
          - uppf-service
          - regulatory-service
          - configuration-service
          - accounting-service
          - inventory-service
          - customer-service
          - fleet-service
          - payment-service
          - ai-forecasting-service
          - iot-service
          - fraud-detection-service
          - forex-service
          - ml-platform
          - dashboard
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_PREFIX }}/${{ matrix.service }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=raw,value=${{ needs.pre-deployment.outputs.version }}
          type=raw,value=latest,enable={{is_default_branch}}
        
    - name: Determine Dockerfile path
      id: dockerfile
      run: |
        if [ "${{ matrix.service }}" = "dashboard" ]; then
          echo "dockerfile=apps/dashboard/Dockerfile" >> $GITHUB_OUTPUT
        elif [ "${{ matrix.service }}" = "ml-platform" ]; then
          echo "dockerfile=services/ml-platform/Dockerfile" >> $GITHUB_OUTPUT
        else
          echo "dockerfile=services/${{ matrix.service }}/Dockerfile" >> $GITHUB_OUTPUT
        fi
        
    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ${{ steps.dockerfile.outputs.dockerfile }}
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64,linux/arm64
        
    - name: Sign container images
      env:
        COSIGN_EXPERIMENTAL: 1
      run: |
        echo "${{ steps.meta.outputs.tags }}" | xargs -I {} cosign sign {}@${{ steps.build.outputs.digest }}
      continue-on-error: true
        
    - name: Generate SBOM
      uses: anchore/sbom-action@v0
      with:
        image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_PREFIX }}/${{ matrix.service }}:${{ needs.pre-deployment.outputs.version }}
        format: spdx-json
        output-file: sbom-${{ matrix.service }}.spdx.json
        
    - name: Upload SBOM
      uses: actions/upload-artifact@v4
      with:
        name: sbom-${{ matrix.service }}
        path: sbom-${{ matrix.service }}.spdx.json
        retention-days: 30

  # ==============================================
  # DEPLOY TO STAGING
  # ==============================================
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: [pre-deployment, build-and-push]
    if: needs.pre-deployment.outputs.environment == 'staging' && needs.pre-deployment.outputs.should_deploy == 'true'
    
    environment:
      name: staging
      url: https://staging.erp.omc.gov.gh
      
    concurrency:
      group: deploy-staging
      cancel-in-progress: false
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}
        
    - name: Update kubeconfig
      run: |
        aws eks update-kubeconfig --region ${{ secrets.AWS_REGION }} --name ${{ secrets.STAGING_CLUSTER_NAME }}
        
    - name: Install kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: ${{ env.KUBECTL_VERSION }}
        
    - name: Install Helm
      uses: azure/setup-helm@v3
      with:
        version: ${{ env.HELM_VERSION }}
        
    - name: Deploy infrastructure components
      run: |
        # Deploy databases first
        kubectl apply -f infrastructure/kubernetes/database/ --namespace=omc-erp-staging
        
        # Wait for databases to be ready
        kubectl wait --for=condition=ready pod -l app=postgres-primary --namespace=omc-erp-staging --timeout=300s
        kubectl wait --for=condition=ready pod -l app=redis-master --namespace=omc-erp-staging --timeout=300s
        
    - name: Run database migrations
      run: |
        kubectl create job migration-${{ github.sha }} \
          --from=cronjob/db-migration-job \
          --namespace=omc-erp-staging
        
        kubectl wait --for=condition=complete job/migration-${{ github.sha }} \
          --namespace=omc-erp-staging --timeout=300s
          
    - name: Deploy services with Helm
      run: |
        helm upgrade --install omc-erp-staging ./helm/omc-erp \
          --namespace=omc-erp-staging \
          --create-namespace \
          --values=helm/omc-erp/values-staging.yaml \
          --set global.image.tag=${{ needs.pre-deployment.outputs.version }} \
          --set global.environment=staging \
          --wait --timeout=600s
          
    - name: Verify deployment
      run: |
        # Check deployment status
        kubectl rollout status deployment/api-gateway --namespace=omc-erp-staging --timeout=300s
        kubectl rollout status deployment/auth-service --namespace=omc-erp-staging --timeout=300s
        kubectl rollout status deployment/dashboard --namespace=omc-erp-staging --timeout=300s
        
        # Run health checks
        kubectl run health-check-${{ github.sha }} \
          --image=curlimages/curl:latest \
          --rm -i --restart=Never \
          --namespace=omc-erp-staging \
          -- curl -f http://api-gateway-service:3000/health
          
    - name: Run smoke tests
      run: |
        cd tests/smoke
        npm ci
        npm run test:staging
      env:
        STAGING_API_URL: https://staging.erp.omc.gov.gh/api
        TEST_USER_EMAIL: ${{ secrets.STAGING_TEST_USER_EMAIL }}
        TEST_USER_PASSWORD: ${{ secrets.STAGING_TEST_USER_PASSWORD }}
        
    - name: Notify deployment success
      if: success()
      uses: 8398a7/action-slack@v3
      with:
        status: success
        text: 'ðŸš€ Staging deployment successful! Version: ${{ needs.pre-deployment.outputs.version }}'
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # ==============================================
  # PRODUCTION APPROVAL
  # ==============================================
  production-approval:
    name: Production Deployment Approval
    runs-on: ubuntu-latest
    needs: [pre-deployment, deploy-staging]
    if: needs.pre-deployment.outputs.environment == 'production' && needs.pre-deployment.outputs.should_deploy == 'true'
    
    environment:
      name: production-approval
      
    steps:
    - name: Request production approval
      run: |
        echo "ðŸ”’ Production deployment requires approval"
        echo "Version: ${{ needs.pre-deployment.outputs.version }}"
        echo "Services: ${{ needs.pre-deployment.outputs.services }}"

  # ==============================================
  # DEPLOY TO PRODUCTION
  # ==============================================
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    timeout-minutes: 45
    needs: [pre-deployment, build-and-push, production-approval]
    if: needs.pre-deployment.outputs.environment == 'production' && needs.pre-deployment.outputs.should_deploy == 'true'
    
    environment:
      name: production
      url: https://erp.omc.gov.gh
      
    concurrency:
      group: deploy-production
      cancel-in-progress: false
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}
        
    - name: Update kubeconfig
      run: |
        aws eks update-kubeconfig --region ${{ secrets.AWS_REGION }} --name ${{ secrets.PRODUCTION_CLUSTER_NAME }}
        
    - name: Install kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: ${{ env.KUBECTL_VERSION }}
        
    - name: Install Helm
      uses: azure/setup-helm@v3
      with:
        version: ${{ env.HELM_VERSION }}
        
    - name: Pre-deployment backup
      run: |
        # Backup current deployment state
        kubectl create job backup-pre-deploy-${{ github.sha }} \
          --from=cronjob/backup-job \
          --namespace=omc-erp
        
        kubectl wait --for=condition=complete job/backup-pre-deploy-${{ github.sha }} \
          --namespace=omc-erp --timeout=600s
          
    - name: Blue-Green deployment preparation
      run: |
        # Scale up green environment
        helm upgrade --install omc-erp-green ./helm/omc-erp \
          --namespace=omc-erp \
          --values=helm/omc-erp/values-production.yaml \
          --set global.image.tag=${{ needs.pre-deployment.outputs.version }} \
          --set global.environment=production \
          --set global.deployment.type=green \
          --wait --timeout=900s
          
    - name: Run production migrations
      run: |
        kubectl create job migration-prod-${{ github.sha }} \
          --from=cronjob/db-migration-job \
          --namespace=omc-erp
        
        kubectl wait --for=condition=complete job/migration-prod-${{ github.sha }} \
          --namespace=omc-erp --timeout=600s
          
    - name: Warm up green environment
      run: |
        # Health checks and warm up
        kubectl run warmup-${{ github.sha }} \
          --image=curlimages/curl:latest \
          --rm -i --restart=Never \
          --namespace=omc-erp \
          -- sh -c "
            for i in {1..10}; do
              curl -f http://api-gateway-green-service:3000/health
              sleep 5
            done
          "
          
    - name: Production smoke tests (Green)
      run: |
        cd tests/smoke
        npm ci
        npm run test:production:green
      env:
        PRODUCTION_GREEN_API_URL: https://green.erp.omc.gov.gh/api
        
    - name: Switch traffic to green (Blue-Green deployment)
      run: |
        # Update service selectors to point to green deployment
        kubectl patch service api-gateway-service --namespace=omc-erp \
          --type='json' -p='[{"op": "replace", "path": "/spec/selector/deployment", "value": "green"}]'
        
        # Update ingress to point to green services
        kubectl patch ingress omc-erp-ingress --namespace=omc-erp \
          --type='json' -p='[{"op": "replace", "path": "/spec/rules/0/http/paths/0/backend/service/name", "value": "api-gateway-green-service"}]'
          
    - name: Monitor production deployment
      run: |
        # Monitor for 5 minutes after switch
        for i in {1..30}; do
          kubectl get pods --namespace=omc-erp -l deployment=green
          kubectl top pods --namespace=omc-erp -l deployment=green
          sleep 10
        done
        
    - name: Verify production deployment
      run: |
        # Final health checks
        kubectl run prod-verify-${{ github.sha }} \
          --image=curlimages/curl:latest \
          --rm -i --restart=Never \
          --namespace=omc-erp \
          -- curl -f https://erp.omc.gov.gh/api/health
          
    - name: Cleanup old blue deployment
      run: |
        # Remove old blue deployment after successful switch
        helm uninstall omc-erp-blue --namespace=omc-erp || true
        
    - name: Update deployment record
      run: |
        kubectl annotate deployment api-gateway-green --namespace=omc-erp \
          deployment.kubernetes.io/revision-history="$(date): ${{ needs.pre-deployment.outputs.version }}"
          
    - name: Notify production deployment success
      if: success()
      uses: 8398a7/action-slack@v3
      with:
        status: success
        text: 'ðŸŽ‰ Production deployment successful! Version: ${{ needs.pre-deployment.outputs.version }}'
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # ==============================================
  # POST-DEPLOYMENT MONITORING
  # ==============================================
  post-deployment-monitoring:
    name: Post-deployment Monitoring
    runs-on: ubuntu-latest
    needs: [pre-deployment, deploy-staging, deploy-production]
    if: always() && (needs.deploy-staging.result == 'success' || needs.deploy-production.result == 'success')
    
    steps:
    - name: Setup monitoring alerts
      run: |
        # This would typically integrate with your monitoring system
        echo "Setting up post-deployment monitoring alerts"
        
    - name: Generate deployment report
      run: |
        echo "## Deployment Report" >> $GITHUB_STEP_SUMMARY
        echo "- **Environment**: ${{ needs.pre-deployment.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Version**: ${{ needs.pre-deployment.outputs.version }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Timestamp**: $(date -u)" >> $GITHUB_STEP_SUMMARY
        echo "- **Status**: ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
        
        if [ "${{ needs.deploy-staging.result }}" = "success" ]; then
          echo "- **Staging URL**: https://staging.erp.omc.gov.gh" >> $GITHUB_STEP_SUMMARY
        fi
        
        if [ "${{ needs.deploy-production.result }}" = "success" ]; then
          echo "- **Production URL**: https://erp.omc.gov.gh" >> $GITHUB_STEP_SUMMARY
        fi

  # ==============================================
  # ROLLBACK CAPABILITY
  # ==============================================
  enable-rollback:
    name: Enable Rollback Capability
    runs-on: ubuntu-latest
    needs: [deploy-production]
    if: needs.deploy-production.result == 'success'
    
    steps:
    - name: Create rollback workflow
      run: |
        # Create a workflow dispatch that can be triggered for rollback
        echo "Rollback capability enabled"
        echo "Previous version tagged and available for rollback"
        
    - name: Tag successful deployment
      run: |
        git tag "deployed-prod-$(date +'%Y%m%d-%H%M%S')"
        git push origin --tags
      continue-on-error: true