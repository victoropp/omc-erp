"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = require("@nestjs/common");
nimport;
{
    InjectRepository;
}
from;
'@nestjs/typeorm';
nimport;
{
    Repository, EntityManager, QueryRunner;
}
from;
'typeorm';
nimport;
{
    EventEmitter2;
}
from;
'@nestjs/event-emitter';
nimport;
{
    Cron, CronExpression;
}
from;
'@nestjs/schedule';
nimport * as;
NodeCache;
from;
'node-cache';
nimport * as;
Redis;
from;
'ioredis';
nimport;
{
    Configuration, ConfigurationModule;
}
from;
'../entities/configuration.entity';
nimport;
{
    PriceBuildupVersion, PriceComponent;
}
from;
'../entities/price-buildup.entity';
n;
ninterface;
CacheEntry;
{
    n;
    value: any;
    n;
    etag: string;
    n;
    lastModified: Date;
    n;
    ttl: number;
    n;
    accessCount: number;
    n;
    lastAccessed: Date;
    n;
}
n;
ninterface;
CacheStatistics;
{
    n;
    totalKeys: number;
    n;
    hits: number;
    n;
    misses: number;
    n;
    hitRate: number;
    n;
    evictions: number;
    n;
    memoryUsage: number;
    n;
}
n;
ninterface;
LockInfo;
{
    n;
    lockId: string;
    n;
    lockKey: string;
    n;
    acquiredBy: string;
    n;
    acquiredAt: Date;
    n;
    expiresAt: Date;
    n;
    operationType: string;
    n;
}
n;
n;
nexport;
class ThreadSafeConfigurationService {
    n;
    logger = new common_1.Logger(ThreadSafeConfigurationService.name);
    n;
    n;
} // Multi-level caching\n  private readonly localCache = new NodeCache({ \n    stdTTL: 300, // 5 minutes for local cache\n    checkperiod: 60, // Check for expired keys every minute\n    useClones: false,\n    maxKeys: 10000,\n  });\n  \n  private redisClient: Redis;\n  \n  // Configuration locks for thread safety\n  private readonly configLocks = new Map<string, LockInfo>();\n  private readonly lockTimeout = 30000; // 30 seconds\n  \n  // Cache statistics\n  private cacheStats = {\n    hits: 0,\n    misses: 0,\n    evictions: 0,\n    operations: 0,\n  };\n  \n  // Batch processing queues\n  private readonly updateQueue = new Map<string, any>();\n  private readonly batchProcessingInterval = 1000; // 1 second\n  \n  constructor(\n    @InjectRepository(Configuration)\n    private configRepository: Repository<Configuration>,\n    \n    @InjectRepository(PriceBuildupVersion)\n    private buildupRepository: Repository<PriceBuildupVersion>,\n    \n    @InjectRepository(PriceComponent)\n    private componentRepository: Repository<PriceComponent>,\n    \n    private eventEmitter: EventEmitter2,\n    private entityManager: EntityManager,\n  ) {\n    this.initializeRedis();\n    this.startBatchProcessor();\n  }\n  \n  async onModuleInit() {\n    await this.warmupCache();\n    this.logger.log('Thread-safe configuration service initialized');\n  }\n  \n  // ===== THREAD-SAFE CONFIGURATION OPERATIONS =====\n  \n  async getConfigurationThreadSafe(\n    key: string,\n    tenantId?: string,\n    module?: ConfigurationModule,\n    useCache: boolean = true\n  ): Promise<any> {\n    const cacheKey = this.buildCacheKey(key, tenantId, module);\n    \n    if (useCache) {\n      // Try local cache first\n      const localValue = await this.getFromLocalCache(cacheKey);\n      if (localValue !== null) {\n        this.cacheStats.hits++;\n        return localValue;\n      }\n      \n      // Try Redis cache\n      const redisValue = await this.getFromRedisCache(cacheKey);\n      if (redisValue !== null) {\n        // Store in local cache for faster subsequent access\n        this.setLocalCache(cacheKey, redisValue, 300);\n        this.cacheStats.hits++;\n        return redisValue;\n      }\n    }\n    \n    this.cacheStats.misses++;\n    \n    // Acquire lock for database read\n    const lockKey = `read_${cacheKey}`;\n    const lockId = await this.acquireLock(lockKey, 'READ', 5000);\n    \n    try {\n      // Double-check cache after acquiring lock\n      if (useCache) {\n        const redisValue = await this.getFromRedisCache(cacheKey);\n        if (redisValue !== null) {\n          this.setLocalCache(cacheKey, redisValue, 300);\n          return redisValue;\n        }\n      }\n      \n      // Read from database\n      const configs = await this.getConfigurationHierarchy(key, tenantId, module);\n      const effectiveValue = this.resolveConfigurationValue(configs);\n      \n      // Cache the result\n      if (useCache && effectiveValue !== null) {\n        const config = configs.find(c => c.key === key);\n        const ttl = config?.cacheTtlSeconds || 300;\n        \n        await this.setRedisCache(cacheKey, effectiveValue, ttl);\n        this.setLocalCache(cacheKey, effectiveValue, Math.min(ttl, 300));\n      }\n      \n      return effectiveValue;\n    } finally {\n      await this.releaseLock(lockId);\n    }\n  }\n  \n  async updateConfigurationThreadSafe(\n    id: string,\n    updateData: any,\n    updatedBy: string\n  ): Promise<Configuration> {\n    const lockKey = `update_config_${id}`;\n    const lockId = await this.acquireLock(lockKey, 'UPDATE', this.lockTimeout);\n    \n    try {\n      return await this.entityManager.transaction(async (manager) => {\n        const config = await manager.findOne(Configuration, { \n          where: { id },\n          lock: { mode: 'pessimistic_write' }\n        });\n        \n        if (!config) {\n          throw new Error(`Configuration ${id} not found`);\n        }\n        \n        // Store previous value for auditing\n        const previousValue = config.value || config.encryptedValue;\n        config.previousValue = previousValue;\n        config.updatedBy = updatedBy;\n        \n        // Update fields\n        Object.assign(config, updateData);\n        \n        // Validate the new value\n        this.validateConfigurationValue(config);\n        \n        const updatedConfig = await manager.save(config);\n        \n        // Invalidate cache\n        await this.invalidateConfigurationCache(config.key, config.tenantId, config.module);\n        \n        // Emit events\n        this.eventEmitter.emit('configuration.updated', {\n          configurationId: updatedConfig.id,\n          key: updatedConfig.key,\n          module: updatedConfig.module,\n          tenantId: updatedConfig.tenantId,\n          previousValue,\n          newValue: updateData.value,\n        });\n        \n        this.logger.log(`Configuration updated safely: ${updatedConfig.key}`);\n        return updatedConfig;\n      });\n    } finally {\n      await this.releaseLock(lockId);\n    }\n  }\n  \n  async bulkUpdateConfigurationsThreadSafe(\n    updates: Array<{ id: string; value: any; changeReason?: string }>,\n    updatedBy: string\n  ): Promise<Configuration[]> {\n    const lockKeys = updates.map(u => `update_config_${u.id}`);\n    const lockIds = await this.acquireMultipleLocks(lockKeys, 'BULK_UPDATE', this.lockTimeout);\n    \n    try {\n      return await this.entityManager.transaction(async (manager) => {\n        const results: Configuration[] = [];\n        const cacheKeysToInvalidate: string[] = [];\n        \n        for (const update of updates) {\n          const config = await manager.findOne(Configuration, {\n            where: { id: update.id },\n            lock: { mode: 'pessimistic_write' }\n          });\n          \n          if (config) {\n            config.previousValue = config.value || config.encryptedValue;\n            config.value = update.value?.toString();\n            config.changeReason = update.changeReason;\n            config.updatedBy = updatedBy;\n            config.changeFrequency += 1;\n            config.lastChangedDate = new Date();\n            \n            const updatedConfig = await manager.save(config);\n            results.push(updatedConfig);\n            \n            // Collect cache keys for batch invalidation\n            const cacheKey = this.buildCacheKey(config.key, config.tenantId, config.module);\n            cacheKeysToInvalidate.push(cacheKey);\n          }\n        }\n        \n        // Batch invalidate cache\n        await this.batchInvalidateCache(cacheKeysToInvalidate);\n        \n        // Emit bulk update event\n        this.eventEmitter.emit('configuration.bulk-updated', {\n          count: results.length,\n          updatedBy,\n          configurationIds: results.map(c => c.id),\n        });\n        \n        this.logger.log(`Bulk updated ${results.length} configurations safely`);\n        return results;\n      });\n    } finally {\n      await this.releaseMultipleLocks(lockIds);\n    }\n  }\n  \n  // ===== PRICE BUILDUP THREAD-SAFE OPERATIONS =====\n  \n  async updatePriceBuildupThreadSafe(\n    buildupVersionId: string,\n    updateData: any,\n    updatedBy: string\n  ): Promise<PriceBuildupVersion> {\n    const lockKey = `update_buildup_${buildupVersionId}`;\n    const lockId = await this.acquireLock(lockKey, 'UPDATE_BUILDUP', this.lockTimeout);\n    \n    try {\n      return await this.entityManager.transaction(async (manager) => {\n        const buildupVersion = await manager.findOne(PriceBuildupVersion, {\n          where: { id: buildupVersionId },\n          relations: ['components'],\n          lock: { mode: 'pessimistic_write' }\n        });\n        \n        if (!buildupVersion || !buildupVersion.canBeModified()) {\n          throw new Error('Cannot modify this price buildup version');\n        }\n        \n        // Update buildup version\n        Object.assign(buildupVersion, updateData, { updatedBy });\n        const updatedBuildupVersion = await manager.save(buildupVersion);\n        \n        // Update components if provided\n        if (updateData.components) {\n          for (const componentUpdate of updateData.components) {\n            const component = await manager.findOne(PriceComponent, {\n              where: { \n                buildupVersionId,\n                componentType: componentUpdate.componentType\n              },\n              lock: { mode: 'pessimistic_write' }\n            });\n            \n            if (component) {\n              Object.assign(component, componentUpdate, { updatedBy });\n              await manager.save(component);\n            }\n          }\n        }\n        \n        // Invalidate price calculation cache\n        await this.invalidatePriceCache(buildupVersion.productType);\n        \n        this.logger.log(`Price buildup updated safely: ${buildupVersionId}`);\n        return updatedBuildupVersion;\n      });\n    } finally {\n      await this.releaseLock(lockId);\n    }\n  }\n  \n  // ===== LOCKING MECHANISM =====\n  \n  private async acquireLock(\n    lockKey: string,\n    operationType: string,\n    timeoutMs: number = this.lockTimeout\n  ): Promise<string> {\n    const lockId = `${lockKey}_${Date.now()}_${Math.random()}`;\n    const expiresAt = new Date(Date.now() + timeoutMs);\n    \n    const startTime = Date.now();\n    \n    while (Date.now() - startTime < timeoutMs) {\n      const existingLock = this.configLocks.get(lockKey);\n      \n      if (!existingLock || existingLock.expiresAt <= new Date()) {\n        // Lock is available or expired\n        const lockInfo: LockInfo = {\n          lockId,\n          lockKey,\n          acquiredBy: 'system', // In real implementation, this would be the user ID\n          acquiredAt: new Date(),\n          expiresAt,\n          operationType,\n        };\n        \n        this.configLocks.set(lockKey, lockInfo);\n        \n        // Also set lock in Redis for distributed locking\n        if (this.redisClient) {\n          await this.redisClient.setex(`lock:${lockKey}`, Math.ceil(timeoutMs / 1000), lockId);\n        }\n        \n        this.logger.debug(`Lock acquired: ${lockKey} by ${lockId}`);\n        return lockId;\n      }\n      \n      // Wait before retrying\n      await this.sleep(10);\n    }\n    \n    throw new Error(`Failed to acquire lock: ${lockKey} after ${timeoutMs}ms`);\n  }\n  \n  private async acquireMultipleLocks(\n    lockKeys: string[],\n    operationType: string,\n    timeoutMs: number = this.lockTimeout\n  ): Promise<string[]> {\n    const lockIds: string[] = [];\n    \n    try {\n      for (const lockKey of lockKeys) {\n        const lockId = await this.acquireLock(lockKey, operationType, timeoutMs);\n        lockIds.push(lockId);\n      }\n      return lockIds;\n    } catch (error) {\n      // Release any acquired locks on failure\n      await this.releaseMultipleLocks(lockIds);\n      throw error;\n    }\n  }\n  \n  private async releaseLock(lockId: string): Promise<void> {\n    for (const [lockKey, lockInfo] of this.configLocks.entries()) {\n      if (lockInfo.lockId === lockId) {\n        this.configLocks.delete(lockKey);\n        \n        // Also remove from Redis\n        if (this.redisClient) {\n          const redisLockId = await this.redisClient.get(`lock:${lockKey}`);\n          if (redisLockId === lockId) {\n            await this.redisClient.del(`lock:${lockKey}`);\n          }\n        }\n        \n        this.logger.debug(`Lock released: ${lockKey} by ${lockId}`);\n        break;\n      }\n    }\n  }\n  \n  private async releaseMultipleLocks(lockIds: string[]): Promise<void> {\n    for (const lockId of lockIds) {\n      await this.releaseLock(lockId);\n    }\n  }\n  \n  // ===== CACHING OPTIMIZATION =====\n  \n  private async getFromLocalCache(key: string): Promise<any> {\n    const entry = this.localCache.get<CacheEntry>(key);\n    if (entry) {\n      entry.accessCount++;\n      entry.lastAccessed = new Date();\n      return entry.value;\n    }\n    return null;\n  }\n  \n  private setLocalCache(key: string, value: any, ttl: number): void {\n    const entry: CacheEntry = {\n      value,\n      etag: this.generateETag(value),\n      lastModified: new Date(),\n      ttl,\n      accessCount: 1,\n      lastAccessed: new Date(),\n    };\n    \n    this.localCache.set(key, entry, ttl);\n  }\n  \n  private async getFromRedisCache(key: string): Promise<any> {\n    if (!this.redisClient) return null;\n    \n    try {\n      const cached = await this.redisClient.get(`cache:${key}`);\n      if (cached) {\n        return JSON.parse(cached);\n      }\n    } catch (error) {\n      this.logger.error(`Redis cache get error: ${error.message}`);\n    }\n    \n    return null;\n  }\n  \n  private async setRedisCache(key: string, value: any, ttl: number): Promise<void> {\n    if (!this.redisClient) return;\n    \n    try {\n      await this.redisClient.setex(`cache:${key}`, ttl, JSON.stringify(value));\n    } catch (error) {\n      this.logger.error(`Redis cache set error: ${error.message}`);\n    }\n  }\n  \n  private async invalidateConfigurationCache(\n    key: string,\n    tenantId?: string,\n    module?: ConfigurationModule\n  ): Promise<void> {\n    const patterns = [\n      this.buildCacheKey(key, tenantId, module),\n      this.buildCacheKey(key, tenantId),\n      this.buildCacheKey(key, undefined, module),\n      this.buildCacheKey(key),\n    ];\n    \n    // Remove from local cache\n    patterns.forEach(pattern => {\n      this.localCache.del(pattern);\n    });\n    \n    // Remove from Redis cache\n    if (this.redisClient) {\n      const pipeline = this.redisClient.pipeline();\n      patterns.forEach(pattern => {\n        pipeline.del(`cache:${pattern}`);\n      });\n      await pipeline.exec();\n    }\n  }\n  \n  private async batchInvalidateCache(cacheKeys: string[]): Promise<void> {\n    // Batch invalidate local cache\n    cacheKeys.forEach(key => this.localCache.del(key));\n    \n    // Batch invalidate Redis cache\n    if (this.redisClient && cacheKeys.length > 0) {\n      const pipeline = this.redisClient.pipeline();\n      cacheKeys.forEach(key => {\n        pipeline.del(`cache:${key}`);\n      });\n      await pipeline.exec();\n    }\n  }\n  \n  private async invalidatePriceCache(productType: string): Promise<void> {\n    const pattern = `price:${productType}:*`;\n    \n    // Remove from local cache\n    const localKeys = this.localCache.keys();\n    localKeys.filter(key => key.startsWith(`price:${productType}:`)).forEach(key => {\n      this.localCache.del(key);\n    });\n    \n    // Remove from Redis cache\n    if (this.redisClient) {\n      const keys = await this.redisClient.keys(`cache:${pattern}`);\n      if (keys.length > 0) {\n        await this.redisClient.del(...keys);\n      }\n    }\n  }\n  \n  // ===== CACHE MANAGEMENT =====\n  \n  @Cron(CronExpression.EVERY_5_MINUTES)\n  async cleanupExpiredLocks(): Promise<void> {\n    const now = new Date();\n    const expiredLocks: string[] = [];\n    \n    for (const [lockKey, lockInfo] of this.configLocks.entries()) {\n      if (lockInfo.expiresAt <= now) {\n        expiredLocks.push(lockKey);\n      }\n    }\n    \n    for (const lockKey of expiredLocks) {\n      this.configLocks.delete(lockKey);\n      if (this.redisClient) {\n        await this.redisClient.del(`lock:${lockKey}`);\n      }\n    }\n    \n    if (expiredLocks.length > 0) {\n      this.logger.log(`Cleaned up ${expiredLocks.length} expired locks`);\n    }\n  }\n  \n  @Cron(CronExpression.EVERY_HOUR)\n  async optimizeCache(): Promise<void> {\n    // Remove least recently used items if cache is getting full\n    const keys = this.localCache.keys();\n    \n    if (keys.length > 8000) { // 80% of max capacity\n      const entries: Array<{ key: string; entry: CacheEntry }> = [];\n      \n      for (const key of keys) {\n        const entry = this.localCache.get<CacheEntry>(key);\n        if (entry) {\n          entries.push({ key, entry });\n        }\n      }\n      \n      // Sort by last accessed time and access count\n      entries.sort((a, b) => {\n        const aScore = a.entry.lastAccessed.getTime() + (a.entry.accessCount * 1000);\n        const bScore = b.entry.lastAccessed.getTime() + (b.entry.accessCount * 1000);\n        return aScore - bScore;\n      });\n      \n      // Remove least used 20%\n      const toRemove = Math.floor(entries.length * 0.2);\n      for (let i = 0; i < toRemove; i++) {\n        this.localCache.del(entries[i].key);\n        this.cacheStats.evictions++;\n      }\n      \n      this.logger.log(`Cache optimized: removed ${toRemove} least used entries`);\n    }\n  }\n  \n  async getCacheStatistics(): Promise<CacheStatistics> {\n    const localStats = this.localCache.getStats();\n    \n    return {\n      totalKeys: localStats.keys,\n      hits: this.cacheStats.hits,\n      misses: this.cacheStats.misses,\n      hitRate: this.cacheStats.hits / (this.cacheStats.hits + this.cacheStats.misses) * 100,\n      evictions: this.cacheStats.evictions,\n      memoryUsage: process.memoryUsage().heapUsed,\n    };\n  }\n  \n  async flushCache(): Promise<void> {\n    this.localCache.flushAll();\n    \n    if (this.redisClient) {\n      const keys = await this.redisClient.keys('cache:*');\n      if (keys.length > 0) {\n        await this.redisClient.del(...keys);\n      }\n    }\n    \n    this.logger.log('Cache flushed');\n  }\n  \n  // ===== INITIALIZATION AND UTILITIES =====\n  \n  private async initializeRedis(): Promise<void> {\n    try {\n      this.redisClient = new Redis({\n        host: process.env.REDIS_HOST || 'localhost',\n        port: parseInt(process.env.REDIS_PORT || '6379'),\n        password: process.env.REDIS_PASSWORD,\n        db: parseInt(process.env.REDIS_DB || '0'),\n        retryDelayOnFailover: 100,\n        enableReadyCheck: true,\n        maxRetriesPerRequest: 3,\n      });\n      \n      this.redisClient.on('connect', () => {\n        this.logger.log('Redis connected for distributed caching');\n      });\n      \n      this.redisClient.on('error', (error) => {\n        this.logger.error(`Redis error: ${error.message}`);\n      });\n    } catch (error) {\n      this.logger.warn(`Redis initialization failed: ${error.message}`);\n    }\n  }\n  \n  private async warmupCache(): Promise<void> {\n    try {\n      // Preload frequently accessed configurations\n      const frequentConfigs = await this.configRepository.find({\n        where: { accessCount: 50 }, // More than 50 accesses\n        take: 100,\n        order: { accessCount: 'DESC' },\n      });\n      \n      for (const config of frequentConfigs) {\n        const cacheKey = this.buildCacheKey(config.key, config.tenantId, config.module);\n        const value = config.getEffectiveValue();\n        \n        this.setLocalCache(cacheKey, value, config.cacheTtlSeconds || 300);\n        await this.setRedisCache(cacheKey, value, config.cacheTtlSeconds || 300);\n      }\n      \n      this.logger.log(`Cache warmed up with ${frequentConfigs.length} configurations`);\n    } catch (error) {\n      this.logger.error(`Cache warmup failed: ${error.message}`);\n    }\n  }\n  \n  private startBatchProcessor(): void {\n    setInterval(() => {\n      this.processBatchUpdates();\n    }, this.batchProcessingInterval);\n  }\n  \n  private async processBatchUpdates(): Promise<void> {\n    if (this.updateQueue.size === 0) return;\n    \n    const updates = Array.from(this.updateQueue.entries());\n    this.updateQueue.clear();\n    \n    // Process updates in batches\n    const batchSize = 50;\n    for (let i = 0; i < updates.length; i += batchSize) {\n      const batch = updates.slice(i, i + batchSize);\n      \n      try {\n        await this.processBatch(batch);\n      } catch (error) {\n        this.logger.error(`Batch processing failed: ${error.message}`);\n      }\n    }\n  }\n  \n  private async processBatch(batch: Array<[string, any]>): Promise<void> {\n    // Implementation would depend on the specific batch operation\n    this.logger.debug(`Processed batch of ${batch.length} operations`);\n  }\n  \n  // ===== HELPER METHODS =====\n  \n  private buildCacheKey(key: string, tenantId?: string, module?: ConfigurationModule): string {\n    return `config:${key}:${tenantId || 'system'}:${module || 'global'}`;\n  }\n  \n  private generateETag(value: any): string {\n    const hash = require('crypto').createHash('md5');\n    hash.update(JSON.stringify(value));\n    return hash.digest('hex');\n  }\n  \n  private sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n  \n  private async getConfigurationHierarchy(\n    key: string,\n    tenantId?: string,\n    module?: ConfigurationModule\n  ): Promise<Configuration[]> {\n    // Implementation from the base configuration service\n    return this.configRepository.find({\n      where: [\n        { key, tenantId: null, module },\n        ...(tenantId ? [{ key, tenantId, module }] : []),\n      ],\n      order: { inheritanceLevel: 'ASC', version: 'DESC' },\n    });\n  }\n  \n  private resolveConfigurationValue(configs: Configuration[]): any {\n    if (configs.length === 0) return null;\n    \n    const sortedConfigs = configs.sort((a, b) => a.inheritanceLevel - b.inheritanceLevel);\n    \n    for (let i = sortedConfigs.length - 1; i >= 0; i--) {\n      const config = sortedConfigs[i];\n      if (config.isEffective()) {\n        return config.getEffectiveValue();\n      }\n    }\n    \n    return null;\n  }\n  \n  private validateConfigurationValue(config: Configuration): void {\n    // Implementation from the base configuration service\n    // Add validation logic here\n  }\n}"
//# sourceMappingURL=thread-safe-config.service.js.map