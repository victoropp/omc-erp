"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
nimport;
{
    InjectRepository;
}
from;
'@nestjs/typeorm';
nimport;
{
    Repository, EntityManager, In;
}
from;
'typeorm';
nimport;
{
    EventEmitter2;
}
from;
'@nestjs/event-emitter';
nimport;
{
    Configuration, ConfigurationStatus, ConfigurationModule;
}
from;
'../entities/configuration.entity';
nimport;
{
    PriceBuildupVersion, PriceComponentStatus;
}
from;
'../entities/price-buildup.entity';
n;
ninterface;
ApprovalRule;
{
    n;
    id: string;
    n;
    name: string;
    n;
    description: string;
    n;
    module: ConfigurationModule;
    n;
    configurationKeys: string[];
    n;
    requiredApprovers: number;
    n;
    approverRoles: string[];
    n;
    approverUsers: string[];
    n;
    isActive: boolean;
    n;
    autoApprovalThreshold ?  : number;
    n;
    escalationTimeHours ?  : number;
    n;
    escalationApprovers ?  : string[];
    n;
}
n;
ninterface;
ApprovalRequest;
{
    n;
    id: string;
    n;
    requestType: 'CONFIGURATION' | 'PRICE_BUILDUP';
    n;
    targetId: string;
} // Configuration ID or PriceBuildupVersion ID\n  requestedBy: string;\n  requestDate: Date;\n  requestReason: string;\n  priority: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';\n  status: 'PENDING' | 'APPROVED' | 'REJECTED' | 'ESCALATED' | 'EXPIRED';\n  requiredApprovals: number;\n  receivedApprovals: number;\n  approvals: ApprovalAction[];\n  escalatedDate?: Date;\n  completedDate?: Date;\n  expiryDate: Date;\n}\n\ninterface ApprovalAction {\n  id: string;\n  approvalRequestId: string;\n  approverUserId: string;\n  approverRole: string;\n  action: 'APPROVE' | 'REJECT' | 'REQUEST_CHANGES';\n  comments: string;\n  actionDate: Date;\n  ipAddress?: string;\n  userAgent?: string;\n}\n\ninterface ApprovalConfiguration {\n  id: string;\n  name: string;\n  module: ConfigurationModule;\n  type: 'AUTOMATIC' | 'MANUAL' | 'CONDITIONAL';\n  conditions: {\n    impactLevel?: string[];\n    valueChangeThreshold?: number;\n    configurationKeys?: string[];\n    userRoles?: string[];\n  };\n  approvalWorkflow: {\n    stages: ApprovalStage[];\n    parallelApproval: boolean;\n    autoApprovalConditions?: any;\n  };\n  isActive: boolean;\n  createdBy: string;\n  createdAt: Date;\n}\n\ninterface ApprovalStage {\n  stageNumber: number;\n  stageName: string;\n  requiredApprovers: number;\n  approverRoles: string[];\n  approverUsers: string[];\n  timeoutHours: number;\n  escalationRules?: {\n    escalateAfterHours: number;\n    escalationApprovers: string[];\n    escalationRoles: string[];\n  };\n}\n\n@Injectable()\nexport class ApprovalWorkflowService {\n  private readonly logger = new Logger(ApprovalWorkflowService.name);\n  private approvalRules: Map<string, ApprovalRule> = new Map();\n  private pendingRequests: Map<string, ApprovalRequest> = new Map();\n\n  constructor(\n    @InjectRepository(Configuration)\n    private configRepository: Repository<Configuration>,\n    \n    @InjectRepository(PriceBuildupVersion)\n    private buildupRepository: Repository<PriceBuildupVersion>,\n    \n    private eventEmitter: EventEmitter2,\n    private entityManager: EntityManager,\n  ) {\n    this.initializeDefaultApprovalRules();\n  }\n\n  // ===== APPROVAL WORKFLOW MANAGEMENT =====\n\n  async requestConfigurationApproval(\n    configurationId: string,\n    requestedBy: string,\n    reason: string,\n    priority: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL' = 'MEDIUM'\n  ): Promise<ApprovalRequest> {\n    const configuration = await this.configRepository.findOne({\n      where: { id: configurationId },\n    });\n\n    if (!configuration) {\n      throw new NotFoundException(`Configuration ${configurationId} not found`);\n    }\n\n    // Check if approval is required\n    const approvalRule = this.getApplicableApprovalRule(configuration);\n    if (!approvalRule) {\n      // Auto-approve if no rule applies\n      await this.autoApproveConfiguration(configurationId, requestedBy);\n      return null;\n    }\n\n    // Create approval request\n    const approvalRequest: ApprovalRequest = {\n      id: this.generateApprovalRequestId(),\n      requestType: 'CONFIGURATION',\n      targetId: configurationId,\n      requestedBy,\n      requestDate: new Date(),\n      requestReason: reason,\n      priority,\n      status: 'PENDING',\n      requiredApprovals: approvalRule.requiredApprovers,\n      receivedApprovals: 0,\n      approvals: [],\n      expiryDate: new Date(Date.now() + (approvalRule.escalationTimeHours || 72) * 60 * 60 * 1000),\n    };\n\n    this.pendingRequests.set(approvalRequest.id, approvalRequest);\n\n    // Update configuration status\n    await this.configRepository.update(configurationId, {\n      status: ConfigurationStatus.PENDING_APPROVAL,\n    });\n\n    // Send notifications to approvers\n    await this.notifyApprovers(approvalRequest, approvalRule);\n\n    // Emit event\n    this.eventEmitter.emit('approval.requested', {\n      approvalRequestId: approvalRequest.id,\n      type: 'CONFIGURATION',\n      targetId: configurationId,\n      requestedBy,\n      priority,\n    });\n\n    this.logger.log(`Approval requested for configuration ${configurationId}`);\n    return approvalRequest;\n  }\n\n  async requestPriceBuildupApproval(\n    buildupVersionId: string,\n    requestedBy: string,\n    reason: string,\n    priority: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL' = 'HIGH'\n  ): Promise<ApprovalRequest> {\n    const buildupVersion = await this.buildupRepository.findOne({\n      where: { id: buildupVersionId },\n    });\n\n    if (!buildupVersion) {\n      throw new NotFoundException(`Price buildup version ${buildupVersionId} not found`);\n    }\n\n    if (buildupVersion.status !== PriceComponentStatus.DRAFT) {\n      throw new BadRequestException('Only draft price buildup versions can be submitted for approval');\n    }\n\n    // Create approval request\n    const approvalRequest: ApprovalRequest = {\n      id: this.generateApprovalRequestId(),\n      requestType: 'PRICE_BUILDUP',\n      targetId: buildupVersionId,\n      requestedBy,\n      requestDate: new Date(),\n      requestReason: reason,\n      priority,\n      status: 'PENDING',\n      requiredApprovals: this.getPriceBuildupRequiredApprovals(buildupVersion),\n      receivedApprovals: 0,\n      approvals: [],\n      expiryDate: new Date(Date.now() + 48 * 60 * 60 * 1000), // 48 hours for price buildup\n    };\n\n    this.pendingRequests.set(approvalRequest.id, approvalRequest);\n\n    // Update price buildup status\n    await this.buildupRepository.update(buildupVersionId, {\n      status: PriceComponentStatus.PENDING_APPROVAL,\n    });\n\n    // Send notifications to approvers\n    await this.notifyPriceBuildupApprovers(approvalRequest, buildupVersion);\n\n    // Emit event\n    this.eventEmitter.emit('approval.requested', {\n      approvalRequestId: approvalRequest.id,\n      type: 'PRICE_BUILDUP',\n      targetId: buildupVersionId,\n      requestedBy,\n      priority,\n    });\n\n    this.logger.log(`Approval requested for price buildup version ${buildupVersionId}`);\n    return approvalRequest;\n  }\n\n  async processApproval(\n    approvalRequestId: string,\n    approverUserId: string,\n    action: 'APPROVE' | 'REJECT' | 'REQUEST_CHANGES',\n    comments: string,\n    ipAddress?: string,\n    userAgent?: string\n  ): Promise<ApprovalRequest> {\n    const approvalRequest = this.pendingRequests.get(approvalRequestId);\n    if (!approvalRequest) {\n      throw new NotFoundException(`Approval request ${approvalRequestId} not found`);\n    }\n\n    if (approvalRequest.status !== 'PENDING') {\n      throw new BadRequestException('Approval request is not pending');\n    }\n\n    // Check if user is authorized to approve\n    await this.validateApproverAuthority(approvalRequest, approverUserId);\n\n    // Check if user has already acted on this request\n    const existingApproval = approvalRequest.approvals.find(a => a.approverUserId === approverUserId);\n    if (existingApproval) {\n      throw new BadRequestException('User has already acted on this approval request');\n    }\n\n    // Create approval action\n    const approvalAction: ApprovalAction = {\n      id: this.generateApprovalActionId(),\n      approvalRequestId,\n      approverUserId,\n      approverRole: await this.getUserRole(approverUserId),\n      action,\n      comments,\n      actionDate: new Date(),\n      ipAddress,\n      userAgent,\n    };\n\n    approvalRequest.approvals.push(approvalAction);\n\n    if (action === 'REJECT' || action === 'REQUEST_CHANGES') {\n      // Rejection or change request - mark as rejected\n      approvalRequest.status = 'REJECTED';\n      approvalRequest.completedDate = new Date();\n      \n      await this.handleApprovalRejection(approvalRequest, approvalAction);\n    } else if (action === 'APPROVE') {\n      // Approval - check if we have enough approvals\n      const approvals = approvalRequest.approvals.filter(a => a.action === 'APPROVE');\n      approvalRequest.receivedApprovals = approvals.length;\n\n      if (approvalRequest.receivedApprovals >= approvalRequest.requiredApprovals) {\n        // Sufficient approvals - complete the request\n        approvalRequest.status = 'APPROVED';\n        approvalRequest.completedDate = new Date();\n        \n        await this.handleApprovalCompletion(approvalRequest);\n      }\n    }\n\n    this.pendingRequests.set(approvalRequestId, approvalRequest);\n\n    // Emit event\n    this.eventEmitter.emit('approval.processed', {\n      approvalRequestId,\n      action,\n      approverUserId,\n      status: approvalRequest.status,\n    });\n\n    this.logger.log(`Approval ${action.toLowerCase()} processed for request ${approvalRequestId}`);\n    return approvalRequest;\n  }\n\n  async getApprovalRequest(approvalRequestId: string): Promise<ApprovalRequest> {\n    const approvalRequest = this.pendingRequests.get(approvalRequestId);\n    if (!approvalRequest) {\n      throw new NotFoundException(`Approval request ${approvalRequestId} not found`);\n    }\n    return approvalRequest;\n  }\n\n  async getUserPendingApprovals(userId: string): Promise<ApprovalRequest[]> {\n    const pendingApprovals: ApprovalRequest[] = [];\n    \n    for (const request of this.pendingRequests.values()) {\n      if (request.status === 'PENDING') {\n        const canApprove = await this.canUserApprove(request, userId);\n        if (canApprove) {\n          pendingApprovals.push(request);\n        }\n      }\n    }\n\n    return pendingApprovals.sort((a, b) => b.requestDate.getTime() - a.requestDate.getTime());\n  }\n\n  async getApprovalHistory(\n    userId?: string,\n    type?: 'CONFIGURATION' | 'PRICE_BUILDUP',\n    status?: string,\n    fromDate?: Date,\n    toDate?: Date\n  ): Promise<ApprovalRequest[]> {\n    let requests = Array.from(this.pendingRequests.values());\n\n    if (userId) {\n      requests = requests.filter(r => \n        r.requestedBy === userId || \n        r.approvals.some(a => a.approverUserId === userId)\n      );\n    }\n\n    if (type) {\n      requests = requests.filter(r => r.requestType === type);\n    }\n\n    if (status) {\n      requests = requests.filter(r => r.status === status);\n    }\n\n    if (fromDate) {\n      requests = requests.filter(r => r.requestDate >= fromDate);\n    }\n\n    if (toDate) {\n      requests = requests.filter(r => r.requestDate <= toDate);\n    }\n\n    return requests.sort((a, b) => b.requestDate.getTime() - a.requestDate.getTime());\n  }\n\n  // ===== PRIVATE HELPER METHODS =====\n\n  private async autoApproveConfiguration(configurationId: string, approvedBy: string): Promise<void> {\n    await this.configRepository.update(configurationId, {\n      status: ConfigurationStatus.ACTIVE,\n      approvedBy,\n      approvalDate: new Date(),\n    });\n\n    this.eventEmitter.emit('approval.auto-approved', {\n      type: 'CONFIGURATION',\n      targetId: configurationId,\n      approvedBy,\n    });\n  }\n\n  private getApplicableApprovalRule(configuration: Configuration): ApprovalRule | null {\n    for (const rule of this.approvalRules.values()) {\n      if (rule.module === configuration.module && rule.isActive) {\n        if (rule.configurationKeys.length === 0 || rule.configurationKeys.includes(configuration.key)) {\n          return rule;\n        }\n      }\n    }\n    return null;\n  }\n\n  private getPriceBuildupRequiredApprovals(buildupVersion: PriceBuildupVersion): number {\n    // High priority items require more approvals\n    if (buildupVersion.productType === 'PETROL' || buildupVersion.productType === 'DIESEL') {\n      return 2; // Major fuel types require 2 approvals\n    }\n    return 1; // Other products require 1 approval\n  }\n\n  private async validateApprovalAuthority(request: ApprovalRequest, userId: string): Promise<void> {\n    const canApprove = await this.canUserApprove(request, userId);\n    if (!canApprove) {\n      throw new ForbiddenException('User is not authorized to approve this request');\n    }\n  }\n\n  private async canUserApprove(request: ApprovalRequest, userId: string): Promise<boolean> {\n    // Check if user has already acted\n    const hasActed = request.approvals.some(a => a.approverUserId === userId);\n    if (hasActed) return false;\n\n    // Check if user is the requester\n    if (request.requestedBy === userId) return false;\n\n    // For this implementation, we'll assume users with certain roles can approve\n    const userRole = await this.getUserRole(userId);\n    const approverRoles = ['admin', 'pricing_approver', 'pricing_manager'];\n    \n    return approverRoles.includes(userRole);\n  }\n\n  private async getUserRole(userId: string): Promise<string> {\n    // This would typically query a user service or database\n    // For now, we'll return a default role\n    return 'pricing_manager';\n  }\n\n  private async handleApprovalCompletion(request: ApprovalRequest): Promise<void> {\n    if (request.requestType === 'CONFIGURATION') {\n      await this.configRepository.update(request.targetId, {\n        status: ConfigurationStatus.ACTIVE,\n        approvedBy: request.approvals[request.approvals.length - 1].approverUserId,\n        approvalDate: new Date(),\n      });\n    } else if (request.requestType === 'PRICE_BUILDUP') {\n      await this.buildupRepository.update(request.targetId, {\n        status: PriceComponentStatus.ACTIVE,\n        approvedBy: request.approvals[request.approvals.length - 1].approverUserId,\n        approvalDate: new Date(),\n      });\n    }\n\n    this.eventEmitter.emit('approval.completed', {\n      approvalRequestId: request.id,\n      type: request.requestType,\n      targetId: request.targetId,\n      approvedBy: request.approvals[request.approvals.length - 1].approverUserId,\n    });\n  }\n\n  private async handleApprovalRejection(request: ApprovalRequest, rejectionAction: ApprovalAction): Promise<void> {\n    if (request.requestType === 'CONFIGURATION') {\n      await this.configRepository.update(request.targetId, {\n        status: ConfigurationStatus.DRAFT,\n      });\n    } else if (request.requestType === 'PRICE_BUILDUP') {\n      await this.buildupRepository.update(request.targetId, {\n        status: PriceComponentStatus.DRAFT,\n      });\n    }\n\n    this.eventEmitter.emit('approval.rejected', {\n      approvalRequestId: request.id,\n      type: request.requestType,\n      targetId: request.targetId,\n      rejectedBy: rejectionAction.approverUserId,\n      reason: rejectionAction.comments,\n    });\n  }\n\n  private async notifyApprovers(request: ApprovalRequest, rule: ApprovalRule): Promise<void> {\n    // This would typically send emails, push notifications, etc.\n    this.logger.log(`Notifying approvers for request ${request.id}`);\n  }\n\n  private async notifyPriceBuildupApprovers(request: ApprovalRequest, buildupVersion: PriceBuildupVersion): Promise<void> {\n    // This would typically send emails, push notifications, etc.\n    this.logger.log(`Notifying price buildup approvers for request ${request.id}`);\n  }\n\n  private generateApprovalRequestId(): string {\n    return `APR-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private generateApprovalActionId(): string {\n    return `ACT-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private initializeDefaultApprovalRules(): void {\n    const defaultRules: ApprovalRule[] = [\n      {\n        id: 'pricing-critical',\n        name: 'Critical Pricing Configuration',\n        description: 'Requires approval for critical pricing configurations',\n        module: ConfigurationModule.PRICING_BUILDUP,\n        configurationKeys: [],\n        requiredApprovers: 2,\n        approverRoles: ['admin', 'pricing_approver'],\n        approverUsers: [],\n        isActive: true,\n        escalationTimeHours: 24,\n      },\n      {\n        id: 'station-config',\n        name: 'Station Configuration Changes',\n        description: 'Requires approval for station configuration changes',\n        module: ConfigurationModule.STATION_CONFIGURATION,\n        configurationKeys: [],\n        requiredApprovers: 1,\n        approverRoles: ['admin', 'station_manager'],\n        approverUsers: [],\n        isActive: true,\n        escalationTimeHours: 48,\n      },\n    ];\n\n    for (const rule of defaultRules) {\n      this.approvalRules.set(rule.id, rule);\n    }\n  }\n\n  // ===== ESCALATION AND TIMEOUT HANDLING =====\n\n  async processEscalations(): Promise<void> {\n    const now = new Date();\n    \n    for (const request of this.pendingRequests.values()) {\n      if (request.status === 'PENDING' && request.expiryDate <= now) {\n        await this.escalateApprovalRequest(request);\n      }\n    }\n  }\n\n  private async escalateApprovalRequest(request: ApprovalRequest): Promise<void> {\n    request.status = 'ESCALATED';\n    request.escalatedDate = new Date();\n    \n    this.eventEmitter.emit('approval.escalated', {\n      approvalRequestId: request.id,\n      type: request.requestType,\n      targetId: request.targetId,\n      escalatedDate: request.escalatedDate,\n    });\n\n    this.logger.warn(`Approval request ${request.id} escalated due to timeout`);\n  }\n\n  // ===== STATISTICS AND REPORTING =====\n\n  async getApprovalStatistics(fromDate?: Date, toDate?: Date): Promise<{\n    totalRequests: number;\n    pendingRequests: number;\n    approvedRequests: number;\n    rejectedRequests: number;\n    escalatedRequests: number;\n    averageApprovalTime: number;\n  }> {\n    let requests = Array.from(this.pendingRequests.values());\n\n    if (fromDate) {\n      requests = requests.filter(r => r.requestDate >= fromDate);\n    }\n\n    if (toDate) {\n      requests = requests.filter(r => r.requestDate <= toDate);\n    }\n\n    const totalRequests = requests.length;\n    const pendingRequests = requests.filter(r => r.status === 'PENDING').length;\n    const approvedRequests = requests.filter(r => r.status === 'APPROVED').length;\n    const rejectedRequests = requests.filter(r => r.status === 'REJECTED').length;\n    const escalatedRequests = requests.filter(r => r.status === 'ESCALATED').length;\n\n    const completedRequests = requests.filter(r => r.completedDate);\n    const totalApprovalTime = completedRequests.reduce((sum, r) => {\n      return sum + (r.completedDate.getTime() - r.requestDate.getTime());\n    }, 0);\n    \n    const averageApprovalTime = completedRequests.length > 0 \n      ? totalApprovalTime / completedRequests.length / (1000 * 60 * 60) // Convert to hours\n      : 0;\n\n    return {\n      totalRequests,\n      pendingRequests,\n      approvedRequests,\n      rejectedRequests,\n      escalatedRequests,\n      averageApprovalTime,\n    };\n  }\n}"
//# sourceMappingURL=approval-workflow.service.js.map