"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var MfaService_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.MfaService = void 0;
const common_1 = require("@nestjs/common");
const config_1 = require("@nestjs/config");
const cache_manager_1 = require("@nestjs/cache-manager");
let MfaService = MfaService_1 = class MfaService {
    configService;
    cacheManager;
    logger = new common_1.Logger(MfaService_1.name);
    backupCodeLength = 8;
    backupCodesCount = 10;
    constructor(configService, cacheManager) {
        this.configService = configService;
        this.cacheManager = cacheManager;
    }
    async generateMfaSetup(userId, userEmail) { n; }
}; // Generate secret\n    const secret = speakeasy.generateSecret({\n      name: `OMC ERP (${userEmail})`,\n      issuer: 'OMC ERP System',\n      length: 32,\n    });\n\n    // Generate QR code\n    const qrCodeDataUrl = await QRCode.toDataURL(secret.otpauth_url!);\n\n    // Generate backup codes\n    const backupCodes = this.generateBackupCodes();\n\n    // Store setup data temporarily (10 minutes)\n    await this.cacheManager.set(\n      `mfa_setup:${userId}`,\n      {\n        secret: secret.base32,\n        backupCodes,\n        userEmail,\n        timestamp: Date.now(),\n      },\n      10 * 60 * 1000 // 10 minutes\n    );\n\n    this.logger.log(`MFA setup initiated for user ${userId}`);\n\n    return {\n      secret: secret.base32,\n      qrCodeUrl: secret.otpauth_url!,\n      qrCodeDataUrl,\n      backupCodes,\n    };\n  }\n\n  async verifyMfaSetup(userId: string, token: string): Promise<{ secret: string; backupCodes: string[] }> {\n    const setupData = await this.cacheManager.get(`mfa_setup:${userId}`) as any;\n    \n    if (!setupData) {\n      throw new BadRequestException('MFA setup session expired or not found');\n    }\n\n    // Verify the TOTP token\n    const isValid = speakeasy.totp.verify({\n      secret: setupData.secret,\n      encoding: 'base32',\n      token,\n      window: 2, // Allow 2 time steps tolerance\n    });\n\n    if (!isValid) {\n      throw new BadRequestException('Invalid TOTP token');\n    }\n\n    // Clear the setup cache\n    await this.cacheManager.del(`mfa_setup:${userId}`);\n\n    this.logger.log(`MFA setup completed for user ${userId}`);\n\n    return {\n      secret: setupData.secret,\n      backupCodes: setupData.backupCodes,\n    };\n  }\n\n  async verifyMfaToken(\n    secret: string,\n    token: string,\n    backupCodes?: string[]\n  ): Promise<MfaVerificationResult> {\n    // First try TOTP verification\n    const isValidTotp = speakeasy.totp.verify({\n      secret,\n      encoding: 'base32',\n      token,\n      window: 2,\n    });\n\n    if (isValidTotp) {\n      return {\n        isValid: true,\n        backupCodeUsed: false,\n      };\n    }\n\n    // If TOTP fails, try backup codes\n    if (backupCodes && backupCodes.length > 0) {\n      const normalizedToken = token.toUpperCase().replace(/\\s/g, '');\n      const codeIndex = backupCodes.indexOf(normalizedToken);\n      \n      if (codeIndex !== -1) {\n        return {\n          isValid: true,\n          backupCodeUsed: true,\n          remainingBackupCodes: backupCodes.length - 1,\n        };\n      }\n    }\n\n    return { isValid: false };\n  }\n\n  async generateNewBackupCodes(): Promise<string[]> {\n    return this.generateBackupCodes();\n  }\n\n  async createMfaSession(userId: string, deviceInfo?: any): Promise<string> {\n    const sessionId = uuidv4();\n    const sessionData = {\n      userId,\n      deviceInfo,\n      createdAt: new Date(),\n      expiresAt: new Date(Date.now() + 5 * 60 * 1000), // 5 minutes\n    };\n\n    await this.cacheManager.set(\n      `mfa_session:${sessionId}`,\n      sessionData,\n      5 * 60 * 1000 // 5 minutes\n    );\n\n    return sessionId;\n  }\n\n  async getMfaSession(sessionId: string): Promise<any> {\n    return this.cacheManager.get(`mfa_session:${sessionId}`);\n  }\n\n  async completeMfaSession(sessionId: string): Promise<void> {\n    await this.cacheManager.del(`mfa_session:${sessionId}`);\n  }\n\n  async createTrustedDevice(userId: string, deviceFingerprint: string): Promise<string> {\n    const deviceId = uuidv4();\n    const deviceData = {\n      userId,\n      fingerprint: deviceFingerprint,\n      createdAt: new Date(),\n      lastUsed: new Date(),\n      expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 days\n    };\n\n    await this.cacheManager.set(\n      `trusted_device:${deviceId}`,\n      deviceData,\n      30 * 24 * 60 * 60 * 1000 // 30 days\n    );\n\n    this.logger.log(`Trusted device created for user ${userId}`);\n    return deviceId;\n  }\n\n  async isTrustedDevice(deviceId: string, deviceFingerprint: string): Promise<boolean> {\n    const deviceData = await this.cacheManager.get(`trusted_device:${deviceId}`) as any;\n    \n    if (!deviceData) {\n      return false;\n    }\n\n    // Check if device fingerprint matches and hasn't expired\n    if (deviceData.fingerprint === deviceFingerprint && new Date() < new Date(deviceData.expiresAt)) {\n      // Update last used timestamp\n      deviceData.lastUsed = new Date();\n      await this.cacheManager.set(\n        `trusted_device:${deviceId}`,\n        deviceData,\n        30 * 24 * 60 * 60 * 1000\n      );\n      \n      return true;\n    }\n\n    return false;\n  }\n\n  async revokeTrustedDevice(userId: string, deviceId: string): Promise<void> {\n    const deviceData = await this.cacheManager.get(`trusted_device:${deviceId}`) as any;\n    \n    if (deviceData && deviceData.userId === userId) {\n      await this.cacheManager.del(`trusted_device:${deviceId}`);\n      this.logger.log(`Trusted device ${deviceId} revoked for user ${userId}`);\n    }\n  }\n\n  async getUserTrustedDevices(userId: string): Promise<any[]> {\n    // This is a simplified implementation\n    // In production, you'd need a more efficient way to query trusted devices by userId\n    const devices: any[] = [];\n    \n    // This would require a more sophisticated caching strategy or database storage\n    // For now, return empty array\n    return devices;\n  }\n\n  generateDeviceFingerprint(request: any): string {\n    const userAgent = request.headers['user-agent'] || '';\n    const acceptLanguage = request.headers['accept-language'] || '';\n    const acceptEncoding = request.headers['accept-encoding'] || '';\n    \n    const fingerprint = crypto\n      .createHash('sha256')\n      .update(userAgent + acceptLanguage + acceptEncoding)\n      .digest('hex');\n    \n    return fingerprint;\n  }\n\n  private generateBackupCodes(): string[] {\n    const codes: string[] = [];\n    \n    for (let i = 0; i < this.backupCodesCount; i++) {\n      // Generate 8-character codes with letters and numbers\n      let code = '';\n      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n      \n      for (let j = 0; j < this.backupCodeLength; j++) {\n        code += chars.charAt(Math.floor(Math.random() * chars.length));\n      }\n      \n      codes.push(code);\n    }\n    \n    return codes;\n  }\n\n  async sendMfaNotification(userId: string, method: 'sms' | 'email', code?: string): Promise<void> {\n    // This would integrate with SMS/Email services\n    // For now, just log the notification\n    \n    if (method === 'sms') {\n      this.logger.log(`SMS MFA code would be sent to user ${userId}: ${code}`);\n    } else if (method === 'email') {\n      this.logger.log(`Email MFA code would be sent to user ${userId}: ${code}`);\n    }\n  }\n\n  generateSmsCode(): string {\n    return Math.floor(100000 + Math.random() * 900000).toString(); // 6-digit code\n  }\n\n  async storeSmsCode(userId: string, code: string, phoneNumber: string): Promise<void> {\n    await this.cacheManager.set(\n      `sms_code:${userId}`,\n      {\n        code,\n        phoneNumber,\n        createdAt: new Date(),\n      },\n      5 * 60 * 1000 // 5 minutes\n    );\n  }\n\n  async verifySmsCode(userId: string, code: string): Promise<boolean> {\n    const storedData = await this.cacheManager.get(`sms_code:${userId}`) as any;\n    \n    if (!storedData) {\n      return false;\n    }\n\n    const isValid = storedData.code === code;\n    \n    if (isValid) {\n      // Remove the code after successful verification\n      await this.cacheManager.del(`sms_code:${userId}`);\n    }\n    \n    return isValid;\n  }\n\n  async getMfaRecoveryCodes(userId: string): Promise<string[]> {\n    // This would typically fetch from database\n    // For now, return empty array\n    return [];\n  }\n\n  async invalidateAllMfaSessions(userId: string): Promise<void> {\n    // This would remove all MFA-related cache entries for the user\n    // Implementation would depend on your caching strategy\n    \n    this.logger.log(`All MFA sessions invalidated for user ${userId}`);\n  }\n}
exports.MfaService = MfaService;
exports.MfaService = MfaService = MfaService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(1, (0, cache_manager_1.Inject)(cache_manager_1.CACHE_MANAGER)),
    __metadata("design:paramtypes", [config_1.ConfigService, Object])
], MfaService);
//# sourceMappingURL=mfa.service.js.map