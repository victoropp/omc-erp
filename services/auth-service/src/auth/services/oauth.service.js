"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
n;
nexport;
var OAuthProvider;
(function (OAuthProvider) {
    OAuthProvider[OAuthProvider["n"] = 0] = "n";
    OAuthProvider["GOOGLE"] = "google";
    OAuthProvider[OAuthProvider["n"] = void 0] = "n";
    OAuthProvider["MICROSOFT"] = "microsoft";
    OAuthProvider[OAuthProvider["n"] = void 0] = "n";
    OAuthProvider["GITHUB"] = "github";
    OAuthProvider[OAuthProvider["n"] = void 0] = "n";
})(OAuthProvider || (OAuthProvider = {}));
n;
nexport;
n;
clientId: string;
n;
clientSecret: string;
n;
redirectUri: string;
n;
scope: string;
n;
authUrl: string;
n;
tokenUrl: string;
n;
userInfoUrl: string;
n;
n;
nexport;
n;
access_token: string;
n;
refresh_token ?  : string;
n;
expires_in: number;
n;
token_type: string;
n;
scope ?  : string;
n;
n;
nexport;
n;
id: string;
n;
email: string;
n;
name: string;
n;
firstName ?  : string;
n;
lastName ?  : string;
n;
avatar ?  : string;
n;
provider: OAuthProvider;
n;
n;
nexport;
n;
state: string;
n;
provider: OAuthProvider;
n;
redirectUri: string;
n;
userId ?  : string; // For linking existing accounts\n  createdAt: Date;\n}\n\n@Injectable()\nexport class OAuthService {\n  private readonly logger = new Logger(OAuthService.name);\n  private readonly stateExpiry = 10 * 60 * 1000; // 10 minutes\n\n  constructor(\n    private configService: ConfigService,\n    private httpService: HttpService,\n    @Inject(CACHE_MANAGER) private cacheManager: Cache,\n  ) {}\n\n  async getAuthorizationUrl(\n    provider: OAuthProvider,\n    redirectUri: string,\n    userId?: string\n  ): Promise<{ authUrl: string; state: string }> {\n    const config = this.getOAuthConfig(provider);\n    const state = this.generateState();\n    \n    // Store state for validation\n    const stateData: OAuthState = {\n      state,\n      provider,\n      redirectUri,\n      userId,\n      createdAt: new Date(),\n    };\n    \n    await this.cacheManager.set(\n      `oauth_state:${state}`,\n      stateData,\n      this.stateExpiry\n    );\n\n    const params = new URLSearchParams({\n      client_id: config.clientId,\n      redirect_uri: redirectUri,\n      scope: config.scope,\n      response_type: 'code',\n      state,\n    });\n\n    if (provider === OAuthProvider.MICROSOFT) {\n      params.append('response_mode', 'query');\n    }\n\n    const authUrl = `${config.authUrl}?${params.toString()}`;\n    \n    this.logger.log(`OAuth authorization URL generated for ${provider}`);\n    \n    return { authUrl, state };\n  }\n\n  async handleCallback(\n    provider: OAuthProvider,\n    code: string,\n    state: string\n  ): Promise<{ userInfo: OAuthUserInfo; isNewUser: boolean; existingUserId?: string }> {\n    // Validate state\n    const stateData = await this.cacheManager.get(`oauth_state:${state}`) as OAuthState;\n    \n    if (!stateData || stateData.provider !== provider) {\n      throw new BadRequestException('Invalid or expired OAuth state');\n    }\n\n    // Clean up state\n    await this.cacheManager.del(`oauth_state:${state}`);\n\n    // Exchange code for tokens\n    const tokenResponse = await this.exchangeCodeForTokens(provider, code, stateData.redirectUri);\n    \n    // Get user info\n    const userInfo = await this.getUserInfo(provider, tokenResponse.access_token);\n    \n    // Check if user already exists\n    const existingUserId = await this.findUserByOAuthProvider(provider, userInfo.id);\n    \n    const result = {\n      userInfo,\n      isNewUser: !existingUserId,\n      existingUserId,\n    };\n\n    this.logger.log(`OAuth callback processed for ${provider}, user: ${userInfo.email}`);\n    \n    return result;\n  }\n\n  async linkOAuthAccount(\n    userId: string,\n    provider: OAuthProvider,\n    code: string,\n    redirectUri: string\n  ): Promise<void> {\n    // Exchange code for tokens\n    const tokenResponse = await this.exchangeCodeForTokens(provider, code, redirectUri);\n    \n    // Get user info\n    const userInfo = await this.getUserInfo(provider, tokenResponse.access_token);\n    \n    // Check if this OAuth account is already linked to another user\n    const existingUserId = await this.findUserByOAuthProvider(provider, userInfo.id);\n    \n    if (existingUserId && existingUserId !== userId) {\n      throw new BadRequestException('This OAuth account is already linked to another user');\n    }\n\n    // Store OAuth account linking\n    await this.storeOAuthAccount(userId, provider, {\n      providerId: userInfo.id,\n      email: userInfo.email,\n      name: userInfo.name,\n      accessToken: tokenResponse.access_token,\n      refreshToken: tokenResponse.refresh_token,\n      expiresAt: new Date(Date.now() + tokenResponse.expires_in * 1000),\n    });\n\n    this.logger.log(`OAuth account linked: ${provider} for user ${userId}`);\n  }\n\n  async unlinkOAuthAccount(userId: string, provider: OAuthProvider): Promise<void> {\n    await this.removeOAuthAccount(userId, provider);\n    this.logger.log(`OAuth account unlinked: ${provider} for user ${userId}`);\n  }\n\n  async getUserOAuthAccounts(userId: string): Promise<Array<{\n    provider: OAuthProvider;\n    email: string;\n    name: string;\n    linkedAt: Date;\n  }>> {\n    // This would typically fetch from database\n    // For demo purposes, return empty array\n    return [];\n  }\n\n  async refreshOAuthToken(userId: string, provider: OAuthProvider): Promise<string | null> {\n    const account = await this.getOAuthAccount(userId, provider);\n    \n    if (!account || !account.refreshToken) {\n      return null;\n    }\n\n    try {\n      const config = this.getOAuthConfig(provider);\n      const tokenResponse = await this.refreshAccessToken(config, account.refreshToken);\n      \n      // Update stored tokens\n      await this.updateOAuthTokens(userId, provider, {\n        accessToken: tokenResponse.access_token,\n        refreshToken: tokenResponse.refresh_token || account.refreshToken,\n        expiresAt: new Date(Date.now() + tokenResponse.expires_in * 1000),\n      });\n\n      return tokenResponse.access_token;\n    } catch (error) {\n      this.logger.error(`Failed to refresh OAuth token for ${provider}`, error);\n      return null;\n    }\n  }\n\n  private async exchangeCodeForTokens(\n    provider: OAuthProvider,\n    code: string,\n    redirectUri: string\n  ): Promise<OAuthTokenResponse> {\n    const config = this.getOAuthConfig(provider);\n    \n    const params = new URLSearchParams({\n      grant_type: 'authorization_code',\n      client_id: config.clientId,\n      client_secret: config.clientSecret,\n      code,\n      redirect_uri: redirectUri,\n    });\n\n    try {\n      const response = await lastValueFrom(\n        this.httpService.post(config.tokenUrl, params.toString(), {\n          headers: {\n            'Content-Type': 'application/x-www-form-urlencoded',\n            'Accept': 'application/json',\n          },\n        })\n      );\n\n      return response.data as OAuthTokenResponse;\n    } catch (error) {\n      this.logger.error(`Failed to exchange code for tokens: ${provider}`, error.response?.data);\n      throw new BadRequestException('Failed to authenticate with OAuth provider');\n    }\n  }\n\n  private async refreshAccessToken(\n    config: OAuthConfig,\n    refreshToken: string\n  ): Promise<OAuthTokenResponse> {\n    const params = new URLSearchParams({\n      grant_type: 'refresh_token',\n      client_id: config.clientId,\n      client_secret: config.clientSecret,\n      refresh_token: refreshToken,\n    });\n\n    const response = await lastValueFrom(\n      this.httpService.post(config.tokenUrl, params.toString(), {\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded',\n          'Accept': 'application/json',\n        },\n      })\n    );\n\n    return response.data as OAuthTokenResponse;\n  }\n\n  private async getUserInfo(provider: OAuthProvider, accessToken: string): Promise<OAuthUserInfo> {\n    const config = this.getOAuthConfig(provider);\n    \n    try {\n      const response = await lastValueFrom(\n        this.httpService.get(config.userInfoUrl, {\n          headers: {\n            'Authorization': `Bearer ${accessToken}`,\n            'Accept': 'application/json',\n          },\n        })\n      );\n\n      const userData = response.data;\n      \n      // Normalize user data based on provider\n      return this.normalizeUserInfo(provider, userData);\n    } catch (error) {\n      this.logger.error(`Failed to get user info from ${provider}`, error.response?.data);\n      throw new BadRequestException('Failed to retrieve user information');\n    }\n  }\n\n  private normalizeUserInfo(provider: OAuthProvider, userData: any): OAuthUserInfo {\n    switch (provider) {\n      case OAuthProvider.GOOGLE:\n        return {\n          id: userData.sub || userData.id,\n          email: userData.email,\n          name: userData.name,\n          firstName: userData.given_name,\n          lastName: userData.family_name,\n          avatar: userData.picture,\n          provider,\n        };\n      \n      case OAuthProvider.MICROSOFT:\n        return {\n          id: userData.id,\n          email: userData.userPrincipalName || userData.mail,\n          name: userData.displayName,\n          firstName: userData.givenName,\n          lastName: userData.surname,\n          provider,\n        };\n      \n      case OAuthProvider.GITHUB:\n        return {\n          id: userData.id.toString(),\n          email: userData.email,\n          name: userData.name || userData.login,\n          firstName: userData.name?.split(' ')[0],\n          lastName: userData.name?.split(' ').slice(1).join(' '),\n          avatar: userData.avatar_url,\n          provider,\n        };\n      \n      default:\n        throw new BadRequestException(`Unsupported OAuth provider: ${provider}`);\n    }\n  }\n\n  private getOAuthConfig(provider: OAuthProvider): OAuthConfig {\n    const baseConfig = {\n      clientId: this.configService.get(`OAUTH_${provider.toUpperCase()}_CLIENT_ID`),\n      clientSecret: this.configService.get(`OAUTH_${provider.toUpperCase()}_CLIENT_SECRET`),\n      redirectUri: this.configService.get(`OAUTH_${provider.toUpperCase()}_REDIRECT_URI`),\n    };\n\n    if (!baseConfig.clientId || !baseConfig.clientSecret) {\n      throw new BadRequestException(`OAuth ${provider} not configured`);\n    }\n\n    const providerConfigs = {\n      [OAuthProvider.GOOGLE]: {\n        ...baseConfig,\n        scope: 'openid email profile',\n        authUrl: 'https://accounts.google.com/o/oauth2/v2/auth',\n        tokenUrl: 'https://oauth2.googleapis.com/token',\n        userInfoUrl: 'https://openidconnect.googleapis.com/v1/userinfo',\n      },\n      [OAuthProvider.MICROSOFT]: {\n        ...baseConfig,\n        scope: 'https://graph.microsoft.com/user.read',\n        authUrl: 'https://login.microsoftonline.com/common/oauth2/v2.0/authorize',\n        tokenUrl: 'https://login.microsoftonline.com/common/oauth2/v2.0/token',\n        userInfoUrl: 'https://graph.microsoft.com/v1.0/me',\n      },\n      [OAuthProvider.GITHUB]: {\n        ...baseConfig,\n        scope: 'user:email',\n        authUrl: 'https://github.com/login/oauth/authorize',\n        tokenUrl: 'https://github.com/login/oauth/access_token',\n        userInfoUrl: 'https://api.github.com/user',\n      },\n    };\n\n    return providerConfigs[provider];\n  }\n\n  private generateState(): string {\n    return crypto.randomBytes(32).toString('hex');\n  }\n\n  // These methods would typically interact with a database\n  // For demo purposes, using in-memory storage\n  private oauthAccounts = new Map<string, Map<OAuthProvider, any>>();\n\n  private async findUserByOAuthProvider(provider: OAuthProvider, providerId: string): Promise<string | null> {\n    // In a real implementation, this would query the database\n    for (const [userId, userAccounts] of this.oauthAccounts.entries()) {\n      const account = userAccounts.get(provider);\n      if (account && account.providerId === providerId) {\n        return userId;\n      }\n    }\n    return null;\n  }\n\n  private async storeOAuthAccount(userId: string, provider: OAuthProvider, accountData: any): Promise<void> {\n    if (!this.oauthAccounts.has(userId)) {\n      this.oauthAccounts.set(userId, new Map());\n    }\n    \n    const userAccounts = this.oauthAccounts.get(userId)!;\n    userAccounts.set(provider, {\n      ...accountData,\n      linkedAt: new Date(),\n    });\n  }\n\n  private async removeOAuthAccount(userId: string, provider: OAuthProvider): Promise<void> {\n    const userAccounts = this.oauthAccounts.get(userId);\n    if (userAccounts) {\n      userAccounts.delete(provider);\n    }\n  }\n\n  private async getOAuthAccount(userId: string, provider: OAuthProvider): Promise<any> {\n    const userAccounts = this.oauthAccounts.get(userId);\n    return userAccounts?.get(provider) || null;\n  }\n\n  private async updateOAuthTokens(\n    userId: string,\n    provider: OAuthProvider,\n    tokens: { accessToken: string; refreshToken: string; expiresAt: Date }\n  ): Promise<void> {\n    const account = await this.getOAuthAccount(userId, provider);\n    if (account) {\n      Object.assign(account, tokens, { updatedAt: new Date() });\n    }\n  }\n}
//# sourceMappingURL=oauth.service.js.map