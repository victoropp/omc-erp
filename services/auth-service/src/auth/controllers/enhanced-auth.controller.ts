import {\n  Controller,\n  Post,\n  Get,\n  Body,\n  UseGuards,\n  Request,\n  HttpCode,\n  HttpStatus,\n  Query,\n  Param,\n  Delete,\n  Put,\n  Req,\n} from '@nestjs/common';\nimport { ApiTags, ApiOperation, ApiResponse, ApiBearerAuth, ApiQuery, ApiParam } from '@nestjs/swagger';\nimport { AuthService } from '../auth.service';\nimport { MfaService } from '../services/mfa.service';\nimport { RbacService } from '../services/rbac.service';\nimport { OAuthService, OAuthProvider } from '../services/oauth.service';\nimport { JwtAuthGuard } from '../guards/jwt-auth.guard';\nimport { RolesGuard } from '../guards/roles.guard';\nimport { PermissionsGuard } from '../guards/permissions.guard';\nimport { ThrottlerGuard } from '@nestjs/throttler';\nimport { Roles } from '../decorators/roles.decorator';\nimport { Permissions } from '../decorators/permissions.decorator';\nimport {\n  SetupMfaDto,\n  VerifyMfaSetupDto,\n  DisableMfaDto,\n  VerifyMfaDto,\n  GenerateBackupCodesDto,\n} from '../dto/mfa.dto';\nimport {\n  OAuthAuthorizationDto,\n  OAuthCallbackDto,\n  LinkOAuthAccountDto,\n  UnlinkOAuthAccountDto,\n} from '../dto/oauth.dto';\nimport {\n  CreateRoleDto,\n  UpdateRoleDto,\n  AssignRoleDto,\n  RemoveRoleDto,\n  CreatePermissionDto,\n  CheckPermissionDto,\n} from '../dto/rbac.dto';\nimport { LoginDto } from '../dto/login.dto';\nimport { RegisterDto } from '../dto/register.dto';\nimport { ChangePasswordDto } from '../dto/change-password.dto';\nimport { ForgotPasswordDto } from '../dto/forgot-password.dto';\nimport { ResetPasswordDto } from '../dto/reset-password.dto';\n\n@ApiTags('Enhanced Authentication')\n@Controller('auth/v2')\n@UseGuards(ThrottlerGuard)\nexport class EnhancedAuthController {\n  constructor(\n    private readonly authService: AuthService,\n    private readonly mfaService: MfaService,\n    private readonly rbacService: RbacService,\n    private readonly oauthService: OAuthService,\n  ) {}\n\n  // ===== BASIC AUTH OPERATIONS =====\n  @Post('register')\n  @ApiOperation({ summary: 'Register a new user with enhanced security' })\n  @ApiResponse({ status: 201, description: 'User registered successfully' })\n  @ApiResponse({ status: 400, description: 'Invalid input or user already exists' })\n  async register(@Body() registerDto: RegisterDto, @Req() req: any) {\n    const result = await this.authService.register(registerDto);\n    return {\n      ...result,\n      securityInfo: {\n        passwordStrengthPassed: true,\n        emailVerificationRequired: true,\n        mfaRecommended: true,\n      },\n    };\n  }\n\n  @Post('login')\n  @HttpCode(HttpStatus.OK)\n  @ApiOperation({ summary: 'Login with email/password and optional MFA' })\n  @ApiResponse({ status: 200, description: 'Login successful or MFA required' })\n  @ApiResponse({ status: 401, description: 'Invalid credentials or account locked' })\n  @ApiResponse({ status: 429, description: 'Too many login attempts' })\n  async login(@Body() loginDto: LoginDto, @Req() req: any) {\n    const ip = req.ip || req.connection.remoteAddress;\n    const userAgent = req.headers['user-agent'];\n    \n    const result = await this.authService.login(loginDto, ip, userAgent);\n    \n    // Add security headers and information\n    return {\n      ...result,\n      loginInfo: {\n        ip,\n        timestamp: new Date().toISOString(),\n        deviceTrustScore: this.calculateDeviceTrustScore(req),\n        securityRecommendations: this.getSecurityRecommendations(result.user),\n      },\n    };\n  }\n\n  @Post('logout')\n  @UseGuards(JwtAuthGuard)\n  @HttpCode(HttpStatus.NO_CONTENT)\n  @ApiBearerAuth()\n  @ApiOperation({ summary: 'Logout user and invalidate session' })\n  @ApiResponse({ status: 204, description: 'Logout successful' })\n  async logout(@Request() req: any) {\n    await this.authService.logout(req.user.sub, req.user.sessionId);\n    return { message: 'Logged out successfully' };\n  }\n\n  @Post('logout-all')\n  @UseGuards(JwtAuthGuard)\n  @HttpCode(HttpStatus.NO_CONTENT)\n  @ApiBearerAuth()\n  @ApiOperation({ summary: 'Logout from all devices' })\n  @ApiResponse({ status: 204, description: 'All sessions terminated' })\n  async logoutAll(@Request() req: any) {\n    await this.authService.logout(req.user.sub); // No sessionId = logout all\n    return { message: 'All sessions terminated' };\n  }\n\n  // ===== MFA OPERATIONS =====\n  @Post('mfa/setup')\n  @UseGuards(JwtAuthGuard)\n  @ApiBearerAuth()\n  @ApiOperation({ summary: 'Setup Multi-Factor Authentication' })\n  @ApiResponse({ status: 200, description: 'MFA setup initiated' })\n  async setupMfa(@Request() req: any, @Body() setupDto: SetupMfaDto) {\n    // Verify current password first\n    const user = await this.authService.verifyCurrentPassword(req.user.sub, setupDto.currentPassword);\n    \n    const mfaSetup = await this.mfaService.generateMfaSetup(req.user.sub, req.user.email);\n    \n    return {\n      ...mfaSetup,\n      instructions: {\n        step1: 'Scan the QR code with your authenticator app (Google Authenticator, Authy, etc.)',\n        step2: 'Enter the 6-digit code from your app to verify setup',\n        step3: 'Save your backup codes in a secure location',\n      },\n    };\n  }\n\n  @Post('mfa/verify-setup')\n  @UseGuards(JwtAuthGuard)\n  @ApiBearerAuth()\n  @ApiOperation({ summary: 'Verify and enable MFA setup' })\n  @ApiResponse({ status: 200, description: 'MFA enabled successfully' })\n  async verifyMfaSetup(@Request() req: any, @Body() verifyDto: VerifyMfaSetupDto) {\n    const result = await this.mfaService.verifyMfaSetup(req.user.sub, verifyDto.token);\n    \n    // Update user MFA status in auth service\n    await this.authService.enableUserMfa(req.user.sub, result.secret, result.backupCodes);\n    \n    return {\n      message: 'MFA enabled successfully',\n      backupCodes: result.backupCodes,\n      warning: 'Store these backup codes securely. They can only be used once.',\n    };\n  }\n\n  @Post('mfa/verify')\n  @ApiOperation({ summary: 'Verify MFA token during login' })\n  @ApiResponse({ status: 200, description: 'MFA verification successful' })\n  async verifyMfa(@Body() verifyDto: VerifyMfaDto, @Req() req: any) {\n    const sessionData = await this.mfaService.getMfaSession(verifyDto.mfaSessionToken);\n    \n    if (!sessionData) {\n      throw new UnauthorizedException('Invalid or expired MFA session');\n    }\n\n    const user = await this.authService.getUserById(sessionData.userId);\n    const verification = await this.mfaService.verifyMfaToken(\n      user.mfaSecret,\n      verifyDto.token,\n      user.mfaBackupCodes\n    );\n\n    if (!verification.isValid) {\n      throw new UnauthorizedException('Invalid MFA token');\n    }\n\n    // Complete MFA session\n    await this.mfaService.completeMfaSession(verifyDto.mfaSessionToken);\n    \n    // If backup code was used, update user's backup codes\n    if (verification.backupCodeUsed) {\n      await this.authService.removeUsedBackupCode(sessionData.userId, verifyDto.token);\n    }\n\n    // Handle trusted device\n    let trustedDeviceId;\n    if (verifyDto.rememberDevice) {\n      const deviceFingerprint = this.mfaService.generateDeviceFingerprint(req);\n      trustedDeviceId = await this.mfaService.createTrustedDevice(sessionData.userId, deviceFingerprint);\n    }\n\n    // Generate final auth tokens\n    const tokens = await this.authService.generateTokensForUser(sessionData.userId);\n    \n    return {\n      ...tokens,\n      mfaVerified: true,\n      backupCodeUsed: verification.backupCodeUsed,\n      remainingBackupCodes: verification.remainingBackupCodes,\n      trustedDeviceId,\n    };\n  }\n\n  @Post('mfa/disable')\n  @UseGuards(JwtAuthGuard)\n  @ApiBearerAuth()\n  @ApiOperation({ summary: 'Disable Multi-Factor Authentication' })\n  @ApiResponse({ status: 200, description: 'MFA disabled successfully' })\n  async disableMfa(@Request() req: any, @Body() disableDto: DisableMfaDto) {\n    await this.authService.disableMfa(req.user.sub, disableDto.currentPassword, disableDto.mfaToken);\n    \n    return {\n      message: 'MFA disabled successfully',\n      warning: 'Your account is now less secure. Consider re-enabling MFA.',\n    };\n  }\n\n  @Post('mfa/backup-codes/generate')\n  @UseGuards(JwtAuthGuard)\n  @ApiBearerAuth()\n  @ApiOperation({ summary: 'Generate new backup codes' })\n  @ApiResponse({ status: 200, description: 'New backup codes generated' })\n  async generateBackupCodes(@Request() req: any, @Body() generateDto: GenerateBackupCodesDto) {\n    const user = await this.authService.verifyCurrentPassword(req.user.sub, generateDto.currentPassword);\n    \n    // Verify MFA token\n    const verification = await this.mfaService.verifyMfaToken(\n      user.mfaSecret,\n      generateDto.mfaToken\n    );\n\n    if (!verification.isValid) {\n      throw new UnauthorizedException('Invalid MFA token');\n    }\n\n    const newBackupCodes = await this.mfaService.generateNewBackupCodes();\n    await this.authService.updateBackupCodes(req.user.sub, newBackupCodes);\n    \n    return {\n      backupCodes: newBackupCodes,\n      message: 'New backup codes generated. Previous codes are no longer valid.',\n    };\n  }\n\n  // ===== OAUTH OPERATIONS =====\n  @Get('oauth/:provider/authorize')\n  @ApiOperation({ summary: 'Get OAuth authorization URL' })\n  @ApiParam({ name: 'provider', enum: OAuthProvider })\n  @ApiQuery({ name: 'redirect_uri', description: 'Redirect URI after authentication' })\n  async getOAuthAuthUrl(\n    @Param('provider') provider: OAuthProvider,\n    @Query('redirect_uri') redirectUri: string,\n    @Query('link_account') linkAccount?: string, // User ID if linking to existing account\n  ) {\n    const result = await this.oauthService.getAuthorizationUrl(\n      provider,\n      redirectUri,\n      linkAccount\n    );\n    \n    return {\n      ...result,\n      provider,\n      instructions: `Visit the authorization URL to authenticate with ${provider}`,\n    };\n  }\n\n  @Post('oauth/:provider/callback')\n  @ApiOperation({ summary: 'Handle OAuth callback' })\n  @ApiParam({ name: 'provider', enum: OAuthProvider })\n  async handleOAuthCallback(\n    @Param('provider') provider: OAuthProvider,\n    @Body() callbackDto: OAuthCallbackDto,\n    @Req() req: any,\n  ) {\n    const result = await this.oauthService.handleCallback(\n      provider,\n      callbackDto.code,\n      callbackDto.state\n    );\n\n    if (result.isNewUser) {\n      // Create new user from OAuth info\n      const newUser = await this.authService.createUserFromOAuth(result.userInfo);\n      const tokens = await this.authService.generateTokensForUser(newUser.id);\n      \n      return {\n        ...tokens,\n        user: newUser,\n        isNewUser: true,\n        provider,\n        accountLinked: true,\n      };\n    } else {\n      // Login existing user\n      const tokens = await this.authService.generateTokensForUser(result.existingUserId!);\n      const user = await this.authService.getUserById(result.existingUserId!);\n      \n      return {\n        ...tokens,\n        user,\n        isNewUser: false,\n        provider,\n      };\n    }\n  }\n\n  @Post('oauth/:provider/link')\n  @UseGuards(JwtAuthGuard)\n  @ApiBearerAuth()\n  @ApiOperation({ summary: 'Link OAuth account to existing user' })\n  @ApiParam({ name: 'provider', enum: OAuthProvider })\n  async linkOAuthAccount(\n    @Param('provider') provider: OAuthProvider,\n    @Request() req: any,\n    @Body() linkDto: LinkOAuthAccountDto,\n  ) {\n    // Verify current password\n    await this.authService.verifyCurrentPassword(req.user.sub, linkDto.currentPassword);\n    \n    await this.oauthService.linkOAuthAccount(\n      req.user.sub,\n      provider,\n      linkDto.code,\n      req.headers.origin || 'http://localhost:3000'\n    );\n    \n    return {\n      message: `${provider} account linked successfully`,\n      provider,\n      linkedAt: new Date().toISOString(),\n    };\n  }\n\n  @Delete('oauth/:provider/unlink')\n  @UseGuards(JwtAuthGuard)\n  @ApiBearerAuth()\n  @ApiOperation({ summary: 'Unlink OAuth account' })\n  @ApiParam({ name: 'provider', enum: OAuthProvider })\n  async unlinkOAuthAccount(\n    @Param('provider') provider: OAuthProvider,\n    @Request() req: any,\n    @Body() unlinkDto: UnlinkOAuthAccountDto,\n  ) {\n    // Verify current password\n    await this.authService.verifyCurrentPassword(req.user.sub, unlinkDto.currentPassword);\n    \n    await this.oauthService.unlinkOAuthAccount(req.user.sub, provider);\n    \n    return {\n      message: `${provider} account unlinked successfully`,\n      provider,\n    };\n  }\n\n  @Get('oauth/accounts')\n  @UseGuards(JwtAuthGuard)\n  @ApiBearerAuth()\n  @ApiOperation({ summary: 'Get linked OAuth accounts' })\n  async getOAuthAccounts(@Request() req: any) {\n    const accounts = await this.oauthService.getUserOAuthAccounts(req.user.sub);\n    \n    return {\n      accounts,\n      totalLinked: accounts.length,\n      availableProviders: Object.values(OAuthProvider),\n    };\n  }\n\n  // ===== RBAC OPERATIONS =====\n  @Post('roles')\n  @UseGuards(JwtAuthGuard, RolesGuard)\n  @Roles('admin')\n  @ApiBearerAuth()\n  @ApiOperation({ summary: 'Create a new role (Admin only)' })\n  async createRole(@Body() createRoleDto: CreateRoleDto) {\n    const role = await this.rbacService.createRole(createRoleDto);\n    return {\n      role,\n      message: 'Role created successfully',\n    };\n  }\n\n  @Get('roles')\n  @UseGuards(JwtAuthGuard, PermissionsGuard)\n  @Permissions('users:read')\n  @ApiBearerAuth()\n  @ApiOperation({ summary: 'Get all roles' })\n  async getAllRoles() {\n    const roles = await this.rbacService.getAllRoles();\n    return {\n      roles,\n      totalRoles: roles.length,\n    };\n  }\n\n  @Put('roles/:id')\n  @UseGuards(JwtAuthGuard, RolesGuard)\n  @Roles('admin')\n  @ApiBearerAuth()\n  @ApiOperation({ summary: 'Update role (Admin only)' })\n  async updateRole(@Param('id') id: string, @Body() updateRoleDto: UpdateRoleDto) {\n    const role = await this.rbacService.updateRole(id, updateRoleDto);\n    return {\n      role,\n      message: 'Role updated successfully',\n    };\n  }\n\n  @Delete('roles/:id')\n  @UseGuards(JwtAuthGuard, RolesGuard)\n  @Roles('admin')\n  @ApiBearerAuth()\n  @ApiOperation({ summary: 'Delete role (Admin only)' })\n  async deleteRole(@Param('id') id: string) {\n    await this.rbacService.deleteRole(id);\n    return {\n      message: 'Role deleted successfully',\n    };\n  }\n\n  @Post('users/roles/assign')\n  @UseGuards(JwtAuthGuard, PermissionsGuard)\n  @Permissions('users:write')\n  @ApiBearerAuth()\n  @ApiOperation({ summary: 'Assign role to user' })\n  async assignRole(@Body() assignRoleDto: AssignRoleDto, @Request() req: any) {\n    await this.rbacService.assignRoleToUser(\n      assignRoleDto.userId,\n      assignRoleDto.roleId,\n      req.user.sub\n    );\n    \n    return {\n      message: 'Role assigned successfully',\n    };\n  }\n\n  @Post('users/roles/remove')\n  @UseGuards(JwtAuthGuard, PermissionsGuard)\n  @Permissions('users:write')\n  @ApiBearerAuth()\n  @ApiOperation({ summary: 'Remove role from user' })\n  async removeRole(@Body() removeRoleDto: RemoveRoleDto) {\n    await this.rbacService.removeRoleFromUser(\n      removeRoleDto.userId,\n      removeRoleDto.roleId\n    );\n    \n    return {\n      message: 'Role removed successfully',\n    };\n  }\n\n  @Get('users/:id/roles')\n  @UseGuards(JwtAuthGuard, PermissionsGuard)\n  @Permissions('users:read')\n  @ApiBearerAuth()\n  @ApiOperation({ summary: 'Get user roles' })\n  async getUserRoles(@Param('id') userId: string) {\n    const roles = await this.rbacService.getUserRoles(userId);\n    return {\n      userId,\n      roles,\n      totalRoles: roles.length,\n    };\n  }\n\n  @Get('users/:id/permissions')\n  @UseGuards(JwtAuthGuard, PermissionsGuard)\n  @Permissions('users:read')\n  @ApiBearerAuth()\n  @ApiOperation({ summary: 'Get user permissions' })\n  async getUserPermissions(@Param('id') userId: string) {\n    const permissions = await this.rbacService.getUserPermissions(userId);\n    return {\n      userId,\n      permissions,\n      totalPermissions: permissions.length,\n    };\n  }\n\n  @Post('permissions/check')\n  @UseGuards(JwtAuthGuard)\n  @ApiBearerAuth()\n  @ApiOperation({ summary: 'Check user permission' })\n  async checkPermission(@Body() checkDto: CheckPermissionDto) {\n    const hasPermission = await this.rbacService.hasPermission(\n      checkDto.userId,\n      checkDto.permission,\n      checkDto.resource\n    );\n    \n    return {\n      userId: checkDto.userId,\n      permission: checkDto.permission,\n      resource: checkDto.resource,\n      hasPermission,\n      checkedAt: new Date().toISOString(),\n    };\n  }\n\n  // ===== ENHANCED PROFILE & SECURITY =====\n  @Get('profile/security')\n  @UseGuards(JwtAuthGuard)\n  @ApiBearerAuth()\n  @ApiOperation({ summary: 'Get security overview' })\n  async getSecurityOverview(@Request() req: any) {\n    const user = await this.authService.getUserById(req.user.sub);\n    const oauthAccounts = await this.oauthService.getUserOAuthAccounts(req.user.sub);\n    const trustedDevices = await this.mfaService.getUserTrustedDevices(req.user.sub);\n    \n    return {\n      userId: req.user.sub,\n      security: {\n        mfaEnabled: user.mfaEnabled,\n        emailVerified: user.emailVerified,\n        passwordLastChanged: user.passwordUpdatedAt,\n        lastLoginAt: user.lastLoginAt,\n        failedLoginAttempts: user.failedLoginAttempts,\n        accountLocked: user.lockedUntil && user.lockedUntil > new Date(),\n      },\n      linkedAccounts: {\n        oauth: oauthAccounts,\n        totalLinked: oauthAccounts.length,\n      },\n      trustedDevices: {\n        devices: trustedDevices,\n        totalDevices: trustedDevices.length,\n      },\n      securityScore: this.calculateSecurityScore(user, oauthAccounts),\n      recommendations: this.getSecurityRecommendations(user),\n    };\n  }\n\n  @Get('sessions')\n  @UseGuards(JwtAuthGuard)\n  @ApiBearerAuth()\n  @ApiOperation({ summary: 'Get active sessions' })\n  async getActiveSessions(@Request() req: any) {\n    const sessions = await this.authService.getUserSessions(req.user.sub);\n    \n    return {\n      userId: req.user.sub,\n      currentSessionId: req.user.sessionId,\n      activeSessions: sessions,\n      totalSessions: sessions.length,\n    };\n  }\n\n  @Delete('sessions/:sessionId')\n  @UseGuards(JwtAuthGuard)\n  @ApiBearerAuth()\n  @ApiOperation({ summary: 'Terminate specific session' })\n  async terminateSession(@Param('sessionId') sessionId: string, @Request() req: any) {\n    await this.authService.terminateSession(req.user.sub, sessionId);\n    \n    return {\n      message: 'Session terminated successfully',\n      terminatedSessionId: sessionId,\n    };\n  }\n\n  // ===== UTILITY METHODS =====\n  private calculateDeviceTrustScore(req: any): number {\n    let score = 50; // Base score\n    \n    // Factors that increase trust\n    if (req.headers['user-agent']) score += 10;\n    if (req.headers['accept-language']) score += 5;\n    if (req.secure) score += 15; // HTTPS\n    if (req.headers['x-forwarded-for']) score -= 10; // Proxy usage\n    \n    return Math.min(100, Math.max(0, score));\n  }\n\n  private calculateSecurityScore(user: any, oauthAccounts: any[]): number {\n    let score = 0;\n    \n    // Base security factors\n    if (user.emailVerified) score += 20;\n    if (user.mfaEnabled) score += 30;\n    if (oauthAccounts.length > 0) score += 10;\n    if (!user.lockedUntil || user.lockedUntil < new Date()) score += 10;\n    if (user.failedLoginAttempts === 0) score += 10;\n    \n    // Password age factor\n    if (user.passwordUpdatedAt) {\n      const daysSinceUpdate = Math.floor(\n        (Date.now() - new Date(user.passwordUpdatedAt).getTime()) / (1000 * 60 * 60 * 24)\n      );\n      if (daysSinceUpdate < 90) score += 10;\n      else if (daysSinceUpdate > 365) score -= 10;\n    }\n    \n    // Recent activity factor\n    if (user.lastLoginAt) {\n      const daysSinceLogin = Math.floor(\n        (Date.now() - new Date(user.lastLoginAt).getTime()) / (1000 * 60 * 60 * 24)\n      );\n      if (daysSinceLogin < 7) score += 10;\n    }\n    \n    return Math.min(100, Math.max(0, score));\n  }\n\n  private getSecurityRecommendations(user: any): string[] {\n    const recommendations: string[] = [];\n    \n    if (!user.mfaEnabled) {\n      recommendations.push('Enable Multi-Factor Authentication for enhanced security');\n    }\n    \n    if (!user.emailVerified) {\n      recommendations.push('Verify your email address');\n    }\n    \n    if (user.passwordUpdatedAt) {\n      const daysSinceUpdate = Math.floor(\n        (Date.now() - new Date(user.passwordUpdatedAt).getTime()) / (1000 * 60 * 60 * 24)\n      );\n      if (daysSinceUpdate > 180) {\n        recommendations.push('Consider updating your password');\n      }\n    }\n    \n    if (user.failedLoginAttempts > 0) {\n      recommendations.push('Review recent login attempts for suspicious activity');\n    }\n    \n    if (recommendations.length === 0) {\n      recommendations.push('Your account security looks good!');\n    }\n    \n    return recommendations;\n  }\n}"