import { Injectable, Logger, BadRequestException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, DataSource, QueryRunner } from 'typeorm';
import { EventEmitter2 } from '@nestjs/event-emitter';
import { Cron, CronExpression } from '@nestjs/schedule';
import { Decimal } from 'decimal.js';
import { format, startOfMonth, endOfMonth, addMonths } from 'date-fns';

import { IFRSAdjustment, IFRSStandard, AdjustmentType, AdjustmentStatus } from './entities/ifrs-adjustment.entity';
import { RevenueRecognitionService } from './revenue-recognition.service';
import { LeaseAccountingService } from './lease-accounting.service';
import { FinancialInstrumentsService } from './financial-instruments.service';
import { ImpairmentService } from './impairment.service';
import { FairValueService } from './fair-value.service';

export interface IFRSAdjustmentData {
  tenantId: string;
  adjustmentDate: Date;
  accountingPeriodId: string;
  ifrsStandard: IFRSStandard;
  adjustmentType: AdjustmentType;
  description: string;
  rationale: string;
  affectedAccounts: string[];
  journalEntries: Array<{
    accountCode: string;
    debitAmount?: number;
    creditAmount?: number;
    description?: string;
  }>;
  sourceSystem?: string;
  sourceDocumentId?: string;
  ifrsParagraphReference?: string;
  measurementModel?: string;
  preparedBy: string;
}

export interface IFRSComplianceReport {
  tenantId: string;
  reportingPeriod: string;
  complianceScore: number; // 0-100
  standards: Array<{
    standard: IFRSStandard;
    complianceStatus: 'COMPLIANT' | 'NON_COMPLIANT' | 'PARTIAL' | 'NOT_APPLICABLE';
    adjustmentsRequired: number;
    criticalIssues: number;
    warnings: number;
  }>;
  criticalIssues: Array<{
    standard: IFRSStandard;
    issue: string;
    impact: 'HIGH' | 'MEDIUM' | 'LOW';
    recommendation: string;
  }>;
  adjustmentsSummary: {
    totalAdjustments: number;
    totalImpact: number;
    currency: string;
    byStandard: Record<string, number>;
  };
}

@Injectable()
export class IFRSComplianceService {
  private readonly logger = new Logger(IFRSComplianceService.name);

  constructor(
    @InjectRepository(IFRSAdjustment)
    private ifrsAdjustmentRepo: Repository<IFRSAdjustment>,
    private dataSource: DataSource,
    private eventEmitter: EventEmitter2,
    private revenueRecognitionService: RevenueRecognitionService,
    private leaseAccountingService: LeaseAccountingService,
    private financialInstrumentsService: FinancialInstrumentsService,
    private impairmentService: ImpairmentService,
    private fairValueService: FairValueService,
  ) {}

  // ===== IFRS ADJUSTMENT MANAGEMENT =====

  async createIFRSAdjustment(data: IFRSAdjustmentData): Promise<IFRSAdjustment> {
    const queryRunner = this.dataSource.createQueryRunner();
    await queryRunner.connect();
    await queryRunner.startTransaction();

    try {
      // Validate journal entries balance
      this.validateJournalEntriesBalance(data.journalEntries);

      // Generate adjustment number
      const adjustmentNumber = await this.generateAdjustmentNumber(
        queryRunner,
        data.ifrsStandard,
        data.adjustmentDate
      );

      // Calculate totals
      const totalDebit = data.journalEntries.reduce(
        (sum, entry) => sum + (entry.debitAmount || 0), 0
      );
      const totalCredit = data.journalEntries.reduce(
        (sum, entry) => sum + (entry.creditAmount || 0), 0
      );

      // Create IFRS adjustment
      const adjustment = this.ifrsAdjustmentRepo.create({
        ...data,
        adjustmentNumber,
        affectedAccounts: JSON.stringify(data.affectedAccounts),
        totalDebitAmount: totalDebit,
        totalCreditAmount: totalCredit,
        status: AdjustmentStatus.DRAFT,
        riskAssessment: await this.assessRisk(data),
        autoGenerated: false,
        manualReviewRequired: this.requiresManualReview(data),
        requiresExternalAudit: this.requiresExternalAudit(data),
        disclosureRequired: this.requiresDisclosure(data),
      });

      const savedAdjustment = await queryRunner.manager.save(adjustment);

      // Create journal entry if approved
      if (savedAdjustment.status === AdjustmentStatus.APPROVED) {
        await this.postAdjustmentToGL(queryRunner, savedAdjustment, data.journalEntries);
      }

      await queryRunner.commitTransaction();

      // Emit event for notification
      this.eventEmitter.emit('ifrs-adjustment.created', {
        adjustmentId: savedAdjustment.id,
        standard: data.ifrsStandard,
        type: data.adjustmentType,
        impact: totalDebit,
      });

      this.logger.log(`IFRS adjustment ${adjustmentNumber} created successfully`);
      return savedAdjustment;

    } catch (error) {
      await queryRunner.rollbackTransaction();
      throw error;
    } finally {
      await queryRunner.release();
    }
  }

  async approveIFRSAdjustment(
    adjustmentId: string,
    approvedBy: string,
    comments?: string
  ): Promise<IFRSAdjustment> {
    const queryRunner = this.dataSource.createQueryRunner();
    await queryRunner.connect();
    await queryRunner.startTransaction();

    try {
      const adjustment = await this.ifrsAdjustmentRepo.findOne({
        where: { id: adjustmentId }
      });

      if (!adjustment) {
        throw new BadRequestException('IFRS adjustment not found');
      }

      if (adjustment.status !== AdjustmentStatus.UNDER_REVIEW) {
        throw new BadRequestException('Adjustment is not ready for approval');
      }

      // Update adjustment status
      adjustment.status = AdjustmentStatus.APPROVED;
      adjustment.approvedBy = approvedBy;
      adjustment.approvalDate = new Date();
      adjustment.lastModifiedBy = approvedBy;

      const updatedAdjustment = await queryRunner.manager.save(adjustment);

      // Post to GL if not already posted
      if (!adjustment.isPostedToGL) {
        const journalEntries = JSON.parse(adjustment.affectedAccounts);
        await this.postAdjustmentToGL(queryRunner, adjustment, journalEntries);
      }

      await queryRunner.commitTransaction();

      // Emit approval event
      this.eventEmitter.emit('ifrs-adjustment.approved', {
        adjustmentId: adjustment.id,
        approvedBy,
        standard: adjustment.ifrsStandard,
      });

      return updatedAdjustment;

    } catch (error) {
      await queryRunner.rollbackTransaction();
      throw error;
    } finally {
      await queryRunner.release();
    }
  }

  // ===== AUTOMATED IFRS COMPLIANCE CHECKS =====

  @Cron(CronExpression.EVERY_DAY_AT_2AM)
  async performDailyComplianceChecks(): Promise<void> {
    this.logger.log('Starting daily IFRS compliance checks');

    try {
      // Get all active tenants
      const tenants = await this.getActiveTenants();

      for (const tenant of tenants) {
        await this.runComplianceChecksForTenant(tenant.tenant_id);
      }

      this.logger.log('Daily IFRS compliance checks completed');
    } catch (error) {
      this.logger.error('Failed to perform daily compliance checks:', error);
    }
  }

  @Cron('0 0 1 * *') // First day of every month
  async performMonthlyComplianceAssessment(): Promise<void> {
    this.logger.log('Starting monthly IFRS compliance assessment');

    try {
      const tenants = await this.getActiveTenants();
      const currentMonth = startOfMonth(new Date());

      for (const tenant of tenants) {
        // Generate comprehensive compliance report
        const report = await this.generateComplianceReport(
          tenant.tenant_id,
          currentMonth
        );

        // Store compliance report
        await this.storeComplianceReport(tenant.tenant_id, report);

        // Send alerts for critical issues
        if (report.criticalIssues.length > 0) {
          this.eventEmitter.emit('ifrs-compliance.critical-issues', {
            tenantId: tenant.tenant_id,
            issues: report.criticalIssues,
            reportingPeriod: format(currentMonth, 'yyyy-MM')
          });
        }
      }

      this.logger.log('Monthly IFRS compliance assessment completed');
    } catch (error) {
      this.logger.error('Failed to perform monthly compliance assessment:', error);
    }
  }

  async generateComplianceReport(
    tenantId: string,
    reportingPeriod: Date
  ): Promise<IFRSComplianceReport> {
    const periodStart = startOfMonth(reportingPeriod);
    const periodEnd = endOfMonth(reportingPeriod);

    // Check compliance for each IFRS standard
    const standardsCompliance = await this.checkAllStandardsCompliance(
      tenantId,
      periodStart,
      periodEnd
    );

    // Calculate overall compliance score
    const complianceScore = this.calculateComplianceScore(standardsCompliance);

    // Get adjustments summary
    const adjustmentsSummary = await this.getAdjustmentsSummary(
      tenantId,
      periodStart,
      periodEnd
    );

    // Identify critical issues
    const criticalIssues = await this.identifyCriticalIssues(
      tenantId,
      standardsCompliance
    );

    return {
      tenantId,
      reportingPeriod: format(reportingPeriod, 'yyyy-MM'),
      complianceScore,
      standards: standardsCompliance,
      criticalIssues,
      adjustmentsSummary,
    };
  }

  // ===== SPECIFIC IFRS STANDARD IMPLEMENTATIONS =====

  async processIFRS15Revenue(tenantId: string, transactionData: any): Promise<void> {
    // IFRS 15 - Revenue from Contracts with Customers
    const adjustments = await this.revenueRecognitionService
      .processRevenueTransaction(tenantId, transactionData);

    if (adjustments.length > 0) {
      for (const adjustment of adjustments) {
        await this.createAutomatedAdjustment(
          tenantId,
          IFRSStandard.IFRS_15,
          AdjustmentType.RECOGNITION,
          adjustment
        );
      }
    }
  }

  async processIFRS16Leases(tenantId: string, leaseData: any): Promise<void> {
    // IFRS 16 - Leases
    const adjustments = await this.leaseAccountingService
      .processLeaseTransaction(tenantId, leaseData);

    if (adjustments.length > 0) {
      for (const adjustment of adjustments) {
        await this.createAutomatedAdjustment(
          tenantId,
          IFRSStandard.IFRS_16,
          AdjustmentType.RECOGNITION,
          adjustment
        );
      }
    }
  }

  async processIFRS9FinancialInstruments(
    tenantId: string,
    instrumentData: any
  ): Promise<void> {
    // IFRS 9 - Financial Instruments
    const adjustments = await this.financialInstrumentsService
      .processFinancialInstrument(tenantId, instrumentData);

    if (adjustments.length > 0) {
      for (const adjustment of adjustments) {
        await this.createAutomatedAdjustment(
          tenantId,
          IFRSStandard.IFRS_9,
          AdjustmentType.MEASUREMENT,
          adjustment
        );
      }
    }
  }

  async processIAS36Impairment(tenantId: string, assetData: any): Promise<void> {
    // IAS 36 - Impairment of Assets
    const impairmentTest = await this.impairmentService
      .performImpairmentTest(tenantId, assetData);

    if (impairmentTest.impairmentRequired) {
      await this.createAutomatedAdjustment(
        tenantId,
        IFRSStandard.IAS_36,
        AdjustmentType.IMPAIRMENT,
        impairmentTest.adjustment
      );
    }
  }

  async processIFRS13FairValue(
    tenantId: string,
    measurementData: any
  ): Promise<void> {
    // IFRS 13 - Fair Value Measurement
    const fairValueAdjustments = await this.fairValueService
      .performFairValueMeasurement(tenantId, measurementData);

    if (fairValueAdjustments.length > 0) {
      for (const adjustment of fairValueAdjustments) {
        await this.createAutomatedAdjustment(
          tenantId,
          IFRSStandard.IFRS_13,
          AdjustmentType.FAIR_VALUE,
          adjustment
        );
      }
    }
  }

  // ===== GHANA-SPECIFIC IFRS COMPLIANCE =====

  async performGhanaSpecificChecks(tenantId: string): Promise<any[]> {
    const issues: any[] = [];

    // Check for ICAG compliance
    const icagIssues = await this.checkICAGCompliance(tenantId);
    issues.push(...icagIssues);

    // Check for Ghana Stock Exchange requirements (if applicable)
    const gseIssues = await this.checkGSERequirements(tenantId);
    issues.push(...gseIssues);

    // Check for Securities and Exchange Commission requirements
    const secIssues = await this.checkSECRequirements(tenantId);
    issues.push(...secIssues);

    // Ghana-specific industry considerations (petroleum sector)
    const industryIssues = await this.checkPetroleumIndustryCompliance(tenantId);
    issues.push(...industryIssues);

    return issues;
  }

  async checkPetroleumIndustryCompliance(tenantId: string): Promise<any[]> {
    const issues: any[] = [];

    // UPPF subsidies recognition under IFRS 15
    const uppfRecognition = await this.checkUPPFRevenueRecognition(tenantId);
    if (!uppfRecognition.compliant) {
      issues.push({
        standard: IFRSStandard.IFRS_15,
        issue: 'UPPF subsidies not properly recognized as contract modifications',
        impact: 'HIGH',
        recommendation: 'Review UPPF subsidy accounting under IFRS 15 guidance'
      });
    }

    // Environmental provisions under IAS 37
    const environmentalProvisions = await this.checkEnvironmentalProvisions(tenantId);
    if (!environmentalProvisions.compliant) {
      issues.push({
        standard: IFRSStandard.IAS_37,
        issue: 'Environmental cleanup provisions insufficient',
        impact: 'MEDIUM',
        recommendation: 'Reassess environmental liabilities for fuel stations'
      });
    }

    // Inventory valuation under IAS 2 (fuel price volatility)
    const inventoryValuation = await this.checkFuelInventoryValuation(tenantId);
    if (!inventoryValuation.compliant) {
      issues.push({
        standard: IFRSStandard.IAS_2,
        issue: 'Fuel inventory valuation method inconsistent',
        impact: 'HIGH',
        recommendation: 'Apply consistent FIFO/weighted average method'
      });
    }

    return issues;
  }

  // ===== PRIVATE HELPER METHODS =====

  private validateJournalEntriesBalance(entries: any[]): void {
    const totalDebits = entries.reduce((sum, entry) => sum + (entry.debitAmount || 0), 0);
    const totalCredits = entries.reduce((sum, entry) => sum + (entry.creditAmount || 0), 0);

    if (Math.abs(totalDebits - totalCredits) > 0.01) {
      throw new BadRequestException(
        `Journal entries are not balanced: Debits=${totalDebits}, Credits=${totalCredits}`
      );
    }
  }

  private async generateAdjustmentNumber(
    queryRunner: QueryRunner,
    standard: IFRSStandard,
    date: Date
  ): Promise<string> {
    const standardCode = standard.split(' ')[1]; // Extract IFRS/IAS number
    const yearMonth = format(date, 'yyyyMM');
    
    const result = await queryRunner.manager.query(
      `SELECT COUNT(*) as count FROM ifrs_adjustments 
       WHERE adjustment_number LIKE $1`,
      [`${standardCode}-${yearMonth}-%`]
    );

    const sequence = (parseInt(result[0].count) + 1).toString().padStart(4, '0');
    return `${standardCode}-${yearMonth}-${sequence}`;
  }

  private async assessRisk(data: IFRSAdjustmentData): Promise<string> {
    // Risk assessment logic based on:
    // - Materiality threshold
    // - Complexity of standard
    // - Management judgment required
    // - Market impact

    const materialityThreshold = 100000; // GHS 100K
    const totalImpact = Math.abs(data.journalEntries.reduce(
      (sum, entry) => sum + (entry.debitAmount || entry.creditAmount || 0), 0
    ));

    if (totalImpact > materialityThreshold * 5) return 'CRITICAL';
    if (totalImpact > materialityThreshold) return 'HIGH';
    if (this.isComplexStandard(data.ifrsStandard)) return 'HIGH';
    if (totalImpact > materialityThreshold * 0.5) return 'MEDIUM';
    return 'LOW';
  }

  private requiresManualReview(data: IFRSAdjustmentData): boolean {
    const complexStandards = [
      IFRSStandard.IFRS_15,
      IFRSStandard.IFRS_16,
      IFRSStandard.IFRS_9,
      IFRSStandard.IFRS_13,
      IFRSStandard.IAS_36,
    ];

    return complexStandards.includes(data.ifrsStandard) || 
           data.adjustmentType === AdjustmentType.FAIR_VALUE ||
           data.adjustmentType === AdjustmentType.IMPAIRMENT;
  }

  private requiresExternalAudit(data: IFRSAdjustmentData): boolean {
    const materialityThreshold = 500000; // GHS 500K
    const totalImpact = Math.abs(data.journalEntries.reduce(
      (sum, entry) => sum + (entry.debitAmount || entry.creditAmount || 0), 0
    ));

    return totalImpact > materialityThreshold ||
           data.adjustmentType === AdjustmentType.IMPAIRMENT ||
           data.adjustmentType === AdjustmentType.FAIR_VALUE;
  }

  private requiresDisclosure(data: IFRSAdjustmentData): boolean {
    // Determine if adjustment requires financial statement disclosure
    return data.adjustmentType === AdjustmentType.FAIR_VALUE ||
           data.adjustmentType === AdjustmentType.IMPAIRMENT ||
           data.ifrsStandard === IFRSStandard.IFRS_7 ||
           data.ifrsStandard === IFRSStandard.IFRS_13;
  }

  private isComplexStandard(standard: IFRSStandard): boolean {
    const complexStandards = [
      IFRSStandard.IFRS_15, // Revenue recognition
      IFRSStandard.IFRS_16, // Leases
      IFRSStandard.IFRS_9,  // Financial instruments
      IFRSStandard.IFRS_13, // Fair value
      IFRSStandard.IAS_36,  // Impairment
      IFRSStandard.IAS_19,  // Employee benefits
    ];

    return complexStandards.includes(standard);
  }

  private async createAutomatedAdjustment(
    tenantId: string,
    standard: IFRSStandard,
    type: AdjustmentType,
    adjustmentData: any
  ): Promise<void> {
    const adjustment = this.ifrsAdjustmentRepo.create({
      tenantId,
      adjustmentDate: new Date(),
      accountingPeriodId: adjustmentData.periodId,
      ifrsStandard: standard,
      adjustmentType: type,
      description: adjustmentData.description,
      rationale: adjustmentData.rationale,
      affectedAccounts: JSON.stringify(adjustmentData.accounts),
      totalDebitAmount: adjustmentData.totalDebit,
      totalCreditAmount: adjustmentData.totalCredit,
      status: AdjustmentStatus.UNDER_REVIEW,
      autoGenerated: true,
      aiConfidenceScore: adjustmentData.confidenceScore,
      manualReviewRequired: true,
      preparedBy: 'system',
    });

    await this.ifrsAdjustmentRepo.save(adjustment);

    // Emit event for review notification
    this.eventEmitter.emit('ifrs-adjustment.auto-generated', {
      adjustmentId: adjustment.id,
      standard,
      type,
      confidenceScore: adjustmentData.confidenceScore,
    });
  }

  private async postAdjustmentToGL(
    queryRunner: QueryRunner,
    adjustment: IFRSAdjustment,
    journalEntries: any[]
  ): Promise<void> {
    // Create journal entry for the adjustment
    const journalData = {
      journalDate: adjustment.adjustmentDate,
      description: `${adjustment.ifrsStandard} - ${adjustment.description}`,
      journalType: 'GENERAL',
      sourceModule: 'IFRS_COMPLIANCE',
      sourceDocumentType: 'IFRS_ADJUSTMENT',
      sourceDocumentId: adjustment.id,
      lines: journalEntries.map((entry, index) => ({
        accountCode: entry.accountCode,
        description: entry.description || adjustment.description,
        debitAmount: entry.debitAmount || 0,
        creditAmount: entry.creditAmount || 0,
      })),
    };

    // This would call the GeneralLedgerService to create the journal entry
    // For now, we'll just mark it as posted
    adjustment.isPostedToGL = true;
    adjustment.postingDate = new Date();
    adjustment.status = AdjustmentStatus.POSTED;

    await queryRunner.manager.save(adjustment);
  }

  private async runComplianceChecksForTenant(tenantId: string): Promise<void> {
    // Run various compliance checks
    await this.checkRevenueRecognitionCompliance(tenantId);
    await this.checkLeaseAccountingCompliance(tenantId);
    await this.checkFinancialInstrumentsCompliance(tenantId);
    await this.checkImpairmentCompliance(tenantId);
    await this.checkFairValueCompliance(tenantId);
    await this.performGhanaSpecificChecks(tenantId);
  }

  private async checkAllStandardsCompliance(
    tenantId: string,
    startDate: Date,
    endDate: Date
  ): Promise<any[]> {
    // This would check compliance for all applicable IFRS standards
    // Return compliance status for each standard
    return []; // Placeholder
  }

  private calculateComplianceScore(standardsCompliance: any[]): number {
    // Calculate weighted compliance score
    return 85; // Placeholder
  }

  private async getAdjustmentsSummary(
    tenantId: string,
    startDate: Date,
    endDate: Date
  ): Promise<any> {
    const result = await this.dataSource.query(`
      SELECT 
        COUNT(*) as total_adjustments,
        SUM(total_debit_amount) as total_impact,
        ifrs_standard,
        COUNT(*) as count_by_standard
      FROM ifrs_adjustments 
      WHERE tenant_id = $1 
        AND adjustment_date BETWEEN $2 AND $3
        AND status = 'POSTED'
      GROUP BY ifrs_standard
    `, [tenantId, startDate, endDate]);

    const totalAdjustments = result.reduce((sum, r) => sum + parseInt(r.total_adjustments), 0);
    const totalImpact = result.reduce((sum, r) => sum + parseFloat(r.total_impact || 0), 0);

    const byStandard = {};
    result.forEach(r => {
      byStandard[r.ifrs_standard] = parseFloat(r.total_impact || 0);
    });

    return {
      totalAdjustments,
      totalImpact,
      currency: 'GHS',
      byStandard,
    };
  }

  private async identifyCriticalIssues(
    tenantId: string,
    standardsCompliance: any[]
  ): Promise<any[]> {
    // Identify critical compliance issues
    return []; // Placeholder
  }

  private async getActiveTenants(): Promise<any[]> {
    return this.dataSource.query(
      'SELECT DISTINCT tenant_id FROM ifrs_adjustments WHERE created_at >= CURRENT_DATE - INTERVAL \'30 days\''
    );
  }

  private async storeComplianceReport(tenantId: string, report: IFRSComplianceReport): Promise<void> {
    // Store compliance report in database for audit trail
    // This would typically go to a compliance_reports table
  }

  // Placeholder methods for specific compliance checks
  private async checkRevenueRecognitionCompliance(tenantId: string): Promise<void> {}
  private async checkLeaseAccountingCompliance(tenantId: string): Promise<void> {}
  private async checkFinancialInstrumentsCompliance(tenantId: string): Promise<void> {}
  private async checkImpairmentCompliance(tenantId: string): Promise<void> {}
  private async checkFairValueCompliance(tenantId: string): Promise<void> {}
  private async checkICAGCompliance(tenantId: string): Promise<any[]> { return []; }
  private async checkGSERequirements(tenantId: string): Promise<any[]> { return []; }
  private async checkSECRequirements(tenantId: string): Promise<any[]> { return []; }
  private async checkUPPFRevenueRecognition(tenantId: string): Promise<any> { return { compliant: true }; }
  private async checkEnvironmentalProvisions(tenantId: string): Promise<any> { return { compliant: true }; }
  private async checkFuelInventoryValuation(tenantId: string): Promise<any> { return { compliant: true }; }
}